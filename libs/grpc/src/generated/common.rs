// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseResult {
    #[prost(enumeration = "ResponseType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Date {
    /// Year
    #[prost(uint64, tag = "1")]
    pub year:  u64,
    /// Month
    #[prost(enumeration = "Month", tag = "2")]
    pub month: i32,
    /// Week
    #[prost(enumeration = "Week", tag = "3")]
    pub week:  i32,
    /// Time
    #[prost(message, optional, tag = "4")]
    pub time:  ::core::option::Option<date::Time>,
    /// Day of month
    #[prost(uint64, tag = "5")]
    pub day:   u64,
}
/// Nested message and enum types in `Date`.
pub mod date {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Time {
        /// Hour
        #[prost(uint64, tag = "1")]
        pub hour: u64,
        /// Min
        #[prost(uint64, tag = "2")]
        pub min:  u64,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionResult {
    #[prost(enumeration = "action_result::Type", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ActionResult`.
pub mod action_result {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// ========== Shared host info  ==========
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommonInfo {
    /// Hostname
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    /// active | stopped
    #[prost(enumeration = "Status", tag = "2")]
    pub status:   i32,
    /// CPU usage
    #[prost(double, tag = "3")]
    pub cpu:      f64,
    /// Memory usage
    #[prost(double, tag = "4")]
    pub memory:   f64,
    /// public ip
    #[prost(string, tag = "5")]
    pub ip:       ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLog {
    /// Date block
    #[prost(message, optional, tag = "1")]
    pub date:    ::core::option::Option<Date>,
    /// Module
    #[prost(string, tag = "2")]
    pub module:  ::prost::alloc::string::String,
    /// debug|info|notice|warn|error|crit|alert|emerg
    #[prost(enumeration = "LogLevel", tag = "3")]
    pub level:   i32,
    /// Pid
    #[prost(uint64, tag = "4")]
    pub pid:     u64,
    /// IP:Port
    #[prost(string, tag = "5")]
    pub client:  ::prost::alloc::string::String,
    /// Message
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseType {
    Unspecified = 0,
    Ok = 1,
    Err = 2,
}
impl ResponseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESPONSE_TYPE_UNSPECIFIED",
            Self::Ok => "OK",
            Self::Err => "ERR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESPONSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "OK" => Some(Self::Ok),
            "ERR" => Some(Self::Err),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Week {
    Unspecified = 0,
    Mon = 1,
    Tue = 2,
    Wed = 3,
    Thu = 4,
    Fri = 5,
    Sat = 6,
    Sun = 7,
}
impl Week {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WEEK_UNSPECIFIED",
            Self::Mon => "MON",
            Self::Tue => "TUE",
            Self::Wed => "WED",
            Self::Thu => "THU",
            Self::Fri => "FRI",
            Self::Sat => "SAT",
            Self::Sun => "SUN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WEEK_UNSPECIFIED" => Some(Self::Unspecified),
            "MON" => Some(Self::Mon),
            "TUE" => Some(Self::Tue),
            "WED" => Some(Self::Wed),
            "THU" => Some(Self::Thu),
            "FRI" => Some(Self::Fri),
            "SAT" => Some(Self::Sat),
            "SUN" => Some(Self::Sun),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Month {
    Unspecified = 0,
    Jan = 1,
    Feb = 2,
    Mar = 3,
    Apr = 4,
    May = 5,
    Jun = 6,
    Jul = 7,
    Aug = 8,
    Sep = 9,
    Oct = 10,
    Nov = 11,
    Dec = 12,
}
impl Month {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MONTH_UNSPECIFIED",
            Self::Jan => "JAN",
            Self::Feb => "FEB",
            Self::Mar => "MAR",
            Self::Apr => "APR",
            Self::May => "MAY",
            Self::Jun => "JUN",
            Self::Jul => "JUL",
            Self::Aug => "AUG",
            Self::Sep => "SEP",
            Self::Oct => "OCT",
            Self::Nov => "NOV",
            Self::Dec => "DEC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MONTH_UNSPECIFIED" => Some(Self::Unspecified),
            "JAN" => Some(Self::Jan),
            "FEB" => Some(Self::Feb),
            "MAR" => Some(Self::Mar),
            "APR" => Some(Self::Apr),
            "MAY" => Some(Self::May),
            "JUN" => Some(Self::Jun),
            "JUL" => Some(Self::Jul),
            "AUG" => Some(Self::Aug),
            "SEP" => Some(Self::Sep),
            "OCT" => Some(Self::Oct),
            "NOV" => Some(Self::Nov),
            "DEC" => Some(Self::Dec),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Unspecified = 0,
    /// active
    Active = 1,
    /// stopped
    Stopped = 2,
    /// not installed
    Uninstalled = 3,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATUS_UNSPECIFIED",
            Self::Active => "ACTIVE",
            Self::Stopped => "STOPPED",
            Self::Uninstalled => "UNINSTALLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "STOPPED" => Some(Self::Stopped),
            _ => None,
        }
    }
}
/// ========== Error log entry  ==========
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LogLevel {
    Unspecified = 0,
    Debug = 1,
    Info = 2,
    Notice = 3,
    Warn = 4,
    Error = 5,
    Crit = 6,
    Alert = 7,
    Emerg = 8,
}
impl LogLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LOG_LEVEL_UNSPECIFIED",
            Self::Debug => "DEBUG",
            Self::Info => "INFO",
            Self::Notice => "NOTICE",
            Self::Warn => "WARN",
            Self::Error => "ERROR",
            Self::Crit => "CRIT",
            Self::Alert => "ALERT",
            Self::Emerg => "EMERG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOG_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "DEBUG" => Some(Self::Debug),
            "INFO" => Some(Self::Info),
            "NOTICE" => Some(Self::Notice),
            "WARN" => Some(Self::Warn),
            "ERROR" => Some(Self::Error),
            "CRIT" => Some(Self::Crit),
            "ALERT" => Some(Self::Alert),
            "EMERG" => Some(Self::Emerg),
            _ => None,
        }
    }
}
