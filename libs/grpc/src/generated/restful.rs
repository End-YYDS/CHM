// This file is @generated by prost-build.
/// ========== Info 專用型別 ==========
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InfoCounts {
    #[prost(int64, tag = "1")]
    pub safe: i64,
    #[prost(int64, tag = "2")]
    pub warn: i64,
    #[prost(int64, tag = "3")]
    pub dang: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClusterSummary {
    #[prost(double, tag = "1")]
    pub cpu:    f64,
    #[prost(double, tag = "2")]
    pub memory: f64,
    #[prost(double, tag = "3")]
    pub disk:   f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PcMetrics {
    #[prost(double, tag = "1")]
    pub cpu:    f64,
    #[prost(double, tag = "2")]
    pub memory: f64,
    #[prost(double, tag = "3")]
    pub disk:   f64,
}
/// ========== Login ==========
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginRequest {
    #[prost(string, tag = "1")]
    pub username: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoginResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// ========== Info ==========
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllInfoRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub info:    ::core::option::Option<InfoCounts>,
    #[prost(message, optional, tag = "2")]
    pub cluster: ::core::option::Option<ClusterSummary>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {
    #[prost(enumeration = "Zone", tag = "1")]
    pub zone:   i32,
    #[prost(enumeration = "Target", tag = "2")]
    pub target: i32,
    #[prost(string, optional, tag = "3")]
    pub uuid:   ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcMetrics>,
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// ========== Config ==========
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetConfigResponse {
    #[prost(uint64, tag = "1")]
    pub reload_rate: u64,
}
/// ========== Backup ==========
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupNowRequest {
    #[prost(enumeration = "BackupLocation", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub name:   ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupNowResponse {
    #[prost(message, optional, tag = "1")]
    pub result:       ::core::option::Option<super::common::ResponseResult>,
    #[prost(string, optional, tag = "2")]
    pub id:           ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub download_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBackupsRequest {
    #[prost(uint64, tag = "1")]
    pub limit: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupEntry {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub date: ::core::option::Option<super::common::Date>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub backups: ::prost::alloc::vec::Vec<BackupEntry>,
    #[prost(uint64, tag = "2")]
    pub length:  u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReductionRequest {
    #[prost(enumeration = "BackupLocation", tag = "1")]
    pub r#type: i32,
    #[prost(oneof = "reduction_request::Source", tags = "2, 3")]
    pub source: ::core::option::Option<reduction_request::Source>,
}
/// Nested message and enum types in `ReductionRequest`.
pub mod reduction_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        File(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReductionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// ========== mCA: 有效憑證列表 ==========
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetValidCertsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidCert {
    /// 通用名稱
    #[prost(string, tag = "1")]
    pub name:   ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub signer: ::prost::alloc::string::String,
    /// 有效期間
    #[prost(string, tag = "3")]
    pub period: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetValidCertsResponse {
    /// 有效憑證清單
    #[prost(message, repeated, tag = "1")]
    pub valid:  ::prost::alloc::vec::Vec<ValidCert>,
    /// valid.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// ========== mCA: 已吊銷憑證列表 ==========
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRevokedCertsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokedCert {
    /// 序號
    #[prost(string, tag = "1")]
    pub number: ::prost::alloc::string::String,
    /// 吊銷時間
    #[prost(string, tag = "2")]
    pub time:   ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRevokedCertsResponse {
    /// 已吊銷憑證清單
    #[prost(message, repeated, tag = "1")]
    pub revoke: ::prost::alloc::vec::Vec<RevokedCert>,
    /// revoke.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// ========== mCA: 吊銷憑證 ==========
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeCertRequest {
    /// 通用名稱
    #[prost(string, tag = "1")]
    pub name:   ::prost::alloc::string::String,
    /// 吊銷原因
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeCertResponse {
    /// Type + Message
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 新增管理主機 POST /api/chm/pc/add
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPcRequest {
    /// 實體 IP
    #[prost(string, tag = "1")]
    pub ip:       ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPcResponse {
    /// Type/Message
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 取得所有主機 GET /api/chm/pc/all
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllPcsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcSimple {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ip:       ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllPcsResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcSimple>,
    /// pcs.len()
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 取得特定主機 GET /api/chm/pc/specific
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecificPcsRequest {
    /// 多個 UUID
    #[prost(string, repeated, tag = "1")]
    pub uuid: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecificPcsResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcSimple>,
    /// pcs.len()
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 刪除管理主機 DELETE /api/chm/pc
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePcsRequest {
    #[prost(string, repeated, tag = "1")]
    pub uuids:     ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub passwords: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePcsResponse {
    /// 每台主機各自的結果
    ///
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub results:
        ::std::collections::HashMap<::prost::alloc::string::String, super::common::ResponseResult>,
}
/// Reboot POST /api/chm/pc/reboot
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPcsRequest {
    #[prost(string, repeated, tag = "1")]
    pub uuids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPcsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// Shutdown POST /api/chm/pc/shutdown
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownPcsRequest {
    #[prost(string, repeated, tag = "1")]
    pub uuids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShutdownPcsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 取得所有 PC 群組資訊 GET /api/chm/pcgroup
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPcGroupsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcGroup {
    #[prost(string, tag = "1")]
    pub groupname: ::prost::alloc::string::String,
    /// 以 "uuid.hostname" 字串表示
    #[prost(string, repeated, tag = "2")]
    pub pcs:       ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPcGroupsResponse {
    /// key = vxlanid
    #[prost(map = "int64, message", tag = "1")]
    pub groups: ::std::collections::HashMap<i64, PcGroup>,
    /// groups.len()
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 新增 Group POST /api/chm/pcgroup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePcGroupRequest {
    #[prost(string, tag = "1")]
    pub groupname: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub describe:  ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePcGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新整筆 Group PUT /api/chm/pcgroup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutPcGroupRequest {
    #[prost(int64, tag = "1")]
    pub vxlanid: i64,
    #[prost(message, optional, tag = "2")]
    pub group:   ::core::option::Option<PcGroup>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutPcGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新 Group 單一內容 PATCH /api/chm/pcgroup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPcGroupRequest {
    #[prost(int64, tag = "1")]
    pub vxlanid:   i64,
    /// 只更改單一欄位：目前文件僅示範 Groupname
    #[prost(string, tag = "2")]
    pub groupname: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPcGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 刪除 Group DELETE /api/chm/pcgroup
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeletePcGroupRequest {
    #[prost(int64, tag = "1")]
    pub vxlanid: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePcGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Color {
    #[prost(oneof = "color::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<color::Kind>,
}
/// Nested message and enum types in `Color`.
pub mod color {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// 對應前端 enum（0: Blue, 1: Red…等）
        #[prost(enumeration = "super::PredefinedColor", tag = "1")]
        Predefined(i32),
        /// Custom(String)
        #[prost(string, tag = "2")]
        Custom(::prost::alloc::string::String),
    }
}
/// 角色資訊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoleInfo {
    /// RoleName
    #[prost(string, tag = "1")]
    pub role_name:   ::prost::alloc::string::String,
    /// bit flags
    #[prost(int64, tag = "2")]
    pub permissions: i64,
    #[prost(message, optional, tag = "3")]
    pub color:       ::core::option::Option<Color>,
    /// uid
    #[prost(int64, repeated, tag = "4")]
    pub members:     ::prost::alloc::vec::Vec<i64>,
    /// Members.len
    #[prost(uint64, tag = "5")]
    pub length:      u64,
}
/// 取得所有角色 GET /api/chm/role
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRolesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRolesResponse {
    #[prost(message, repeated, tag = "1")]
    pub roles:  ::prost::alloc::vec::Vec<RoleInfo>,
    /// roles.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 取得所有使用者資訊 GET /api/chm/role/users
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRoleUsersRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoleUsersResponse {
    /// key: uid, value: name
    #[prost(map = "int64, string", tag = "1")]
    pub users:  ::std::collections::HashMap<i64, ::prost::alloc::string::String>,
    /// users.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 建立角色（身份組） POST /api/chm/role
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRoleRequest {
    /// RoleName
    #[prost(string, tag = "1")]
    pub role_name:   ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub permissions: i64,
    /// 可傳預設或自訂
    #[prost(message, optional, tag = "3")]
    pub color:       ::core::option::Option<Color>,
    #[prost(int64, repeated, tag = "4")]
    pub members:     ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRoleResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 刪除角色 DELETE /api/chm/role
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRoleRequest {
    /// RoleName
    #[prost(string, tag = "1")]
    pub role_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRoleResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 角色配置（覆蓋整筆成員） PUT /api/chm/role
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRoleMembersRequest {
    /// RoleName
    #[prost(string, tag = "1")]
    pub role_name: ::prost::alloc::string::String,
    /// 新成員清單（覆蓋）
    #[prost(int64, repeated, tag = "2")]
    pub members:   ::prost::alloc::vec::Vec<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRoleMembersResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 編輯角色權限/顏色（部分欄位） PATCH /api/chm/role
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRoleRequest {
    /// RoleName
    #[prost(string, tag = "1")]
    pub role_name:   ::prost::alloc::string::String,
    /// 若有就更新
    #[prost(int64, optional, tag = "2")]
    pub permissions: ::core::option::Option<i64>,
    /// 若有就更新（message 有 presence）
    #[prost(message, optional, tag = "3")]
    pub color:       ::core::option::Option<Color>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRoleResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Module {
    /// Name
    #[prost(string, tag = "1")]
    pub name:          ::prost::alloc::string::String,
    /// Version
    #[prost(string, tag = "2")]
    pub version:       ::prost::alloc::string::String,
    /// Description
    #[prost(string, tag = "3")]
    pub description:   ::prost::alloc::string::String,
    /// Author
    #[prost(string, tag = "4")]
    pub author:        ::prost::alloc::string::String,
    /// Loadstatus (Load / Notload)
    #[prost(enumeration = "LoadStatus", tag = "5")]
    pub load_status:   i32,
    /// Enablestatus (Enable / Disable)
    #[prost(enumeration = "EnableStatus", tag = "6")]
    pub enable_status: i32,
}
/// GET /api/chm/setting/module
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetModulesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModulesResponse {
    /// key = moduleId (e.g., "module01")
    #[prost(map = "string, message", tag = "1")]
    pub modules: ::std::collections::HashMap<::prost::alloc::string::String, Module>,
    /// modules.len
    #[prost(uint64, tag = "2")]
    pub length:  u64,
}
/// POST /api/chm/setting/module  (multipart/form-data -> 以檔案陣列抽象化)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleFile {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    /// .zip 內容
    #[prost(bytes = "vec", tag = "2")]
    pub content:  ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModulesRequest {
    #[prost(message, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<ModuleFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleLoadReport {
    #[prost(string, repeated, tag = "1")]
    pub load:           ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub notload:        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "3")]
    pub load_length:    u64,
    #[prost(uint64, tag = "4")]
    pub notload_length: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModulesResponse {
    /// { Load, Notload, ... }
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<ModuleLoadReport>,
}
/// PUT /api/chm/setting/module  (更新整個模組；同樣以檔案陣列抽象化)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModulesRequest {
    #[prost(message, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<ModuleFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleUpdateReport {
    #[prost(string, repeated, tag = "1")]
    pub success:        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub fail:           ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "3")]
    pub success_length: u64,
    #[prost(uint64, tag = "4")]
    pub fail_length:    u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModulesResponse {
    /// { Success, Fail, ... }
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<ModuleUpdateReport>,
}
/// PATCH /api/chm/setting/module  (各模組自有設定；內容不定，用檔案/blob
/// 抽象化)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchModuleSettingsRequest {
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<ModuleFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchModuleSettingsResponse {
    #[prost(enumeration = "patch_module_settings_response::ResultType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PatchModuleSettingsResponse`.
pub mod patch_module_settings_response {
    /// 簡單結果：若你的專案已有 common.ResponseResult，改成使用它
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// DELETE /api/chm/setting/module
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModulesRequest {
    /// 要刪除的模組 ID
    #[prost(string, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleDeleteReport {
    #[prost(string, repeated, tag = "1")]
    pub delete:           ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub notdelete:        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "3")]
    pub delete_length:    u64,
    #[prost(uint64, tag = "4")]
    pub notdelete_length: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModulesResponse {
    /// { Delete, Notdelete, ... }
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<ModuleDeleteReport>,
}
/// POST /api/chm/setting/module/action/enable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableModulesRequest {
    #[prost(string, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModuleActionReport {
    #[prost(string, repeated, tag = "1")]
    pub success:        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub fail:           ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "3")]
    pub success_length: u64,
    #[prost(uint64, tag = "4")]
    pub fail_length:    u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableModulesResponse {
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<ModuleActionReport>,
}
/// POST /api/chm/setting/module/action/disable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableModulesRequest {
    #[prost(string, repeated, tag = "1")]
    pub modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableModulesResponse {
    #[prost(message, optional, tag = "1")]
    pub module: ::core::option::Option<ModuleActionReport>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IpAccessTypes {}
/// Nested message and enum types in `IpAccessTypes`.
pub mod ip_access_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum IpAclMode {
        Unspecified = 0,
        None = 1,
        White = 2,
        Black = 3,
    }
    impl IpAclMode {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "IP_ACL_MODE_UNSPECIFIED",
                Self::None => "NONE",
                Self::White => "WHITE",
                Self::Black => "BLACK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IP_ACL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "WHITE" => Some(Self::White),
                "BLACK" => Some(Self::Black),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpEntry {
    /// Name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Ip
    #[prost(string, tag = "2")]
    pub ip:   ::prost::alloc::string::String,
}
/// GET /api/chm/setting/ip
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetIpAccessRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIpAccessResponse {
    /// None / White / Black
    #[prost(enumeration = "ip_access_types::IpAclMode", tag = "1")]
    pub mode:  i32,
    /// key = did（資料庫 id）；若無清單可回空 map
    #[prost(map = "string, message", tag = "2")]
    pub lists: ::std::collections::HashMap<::prost::alloc::string::String, IpEntry>,
}
/// POST /api/chm/setting/ip
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostIpRequest {
    /// White / Black
    #[prost(enumeration = "ip_access_types::IpAclMode", tag = "1")]
    pub mode: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip:   ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostIpResponse {
    #[prost(enumeration = "post_ip_response::ResultType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PostIpResponse`.
pub mod post_ip_response {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// DELETE /api/chm/setting/ip
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIpRequest {
    /// White / Black
    #[prost(enumeration = "ip_access_types::IpAclMode", tag = "1")]
    pub mode: i32,
    /// 資料庫 id
    #[prost(string, tag = "2")]
    pub did:  ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIpResponse {
    #[prost(enumeration = "delete_ip_response::ResultType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeleteIpResponse`.
pub mod delete_ip_response {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// PUT /api/chm/setting/ip  (切換黑/白名單)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PutIpModeRequest {
    /// White / Black
    #[prost(enumeration = "ip_access_types::IpAclMode", tag = "1")]
    pub mode: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutIpModeResponse {
    #[prost(enumeration = "put_ip_mode_response::ResultType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PutIpModeResponse`.
pub mod put_ip_mode_response {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// GET /api/chm/setting/values
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSettingValuesRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Values {
    #[prost(double, tag = "1")]
    pub cpu_usage:  f64,
    #[prost(double, tag = "2")]
    pub disk_usage: f64,
    #[prost(double, tag = "3")]
    pub memory:     f64,
    #[prost(double, tag = "4")]
    pub network:    f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSettingValuesResponse {
    #[prost(message, optional, tag = "1")]
    pub values: ::core::option::Option<Values>,
}
/// PUT /api/chm/setting/values  (單一或整筆更新 -> 使用 optional 欄位)
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PutSettingValuesRequest {
    #[prost(double, optional, tag = "1")]
    pub cpu_usage:  ::core::option::Option<f64>,
    #[prost(double, optional, tag = "2")]
    pub disk_usage: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub memory:     ::core::option::Option<f64>,
    #[prost(double, optional, tag = "4")]
    pub network:    ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutSettingValuesResponse {
    #[prost(enumeration = "put_setting_values_response::ResultType", tag = "1")]
    pub r#type:  i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PutSettingValuesResponse`.
pub mod put_setting_values_response {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResultType {
        Unspecified = 0,
        Ok = 1,
        Err = 2,
    }
    impl ResultType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESULT_TYPE_UNSPECIFIED",
                Self::Ok => "OK",
                Self::Err => "ERR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OK" => Some(Self::Ok),
                "ERR" => Some(Self::Err),
                _ => None,
            }
        }
    }
}
/// 使用者基本資料
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEntry {
    /// Username
    #[prost(string, tag = "1")]
    pub username:       ::prost::alloc::string::String,
    /// Group
    #[prost(string, repeated, tag = "2")]
    pub group:          ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Home_directory
    #[prost(string, tag = "3")]
    pub home_directory: ::prost::alloc::string::String,
    /// Shell
    #[prost(string, tag = "4")]
    pub shell:          ::prost::alloc::string::String,
}
/// 取得所有使用者資訊  GET /api/chm/user
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetUsersRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUsersResponse {
    /// key = uid
    #[prost(map = "string, message", tag = "1")]
    pub users:  ::std::collections::HashMap<::prost::alloc::string::String, UserEntry>,
    /// users.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 新增 User  POST /api/chm/user
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserRequest {
    #[prost(string, tag = "1")]
    pub username:       ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub group:          ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub home_directory: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub shell:          ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUserResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新整筆 User  PUT /api/chm/user
/// 請求為「uid -> 完整 UserEntry」的映射
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutUsersRequest {
    /// 例如 {"uid01": {...}}
    #[prost(map = "string, message", tag = "1")]
    pub users: ::std::collections::HashMap<::prost::alloc::string::String, UserEntry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutUsersResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新 User 單一內容  PATCH /api/chm/user
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPatch {
    #[prost(string, optional, tag = "1")]
    pub username:       ::core::option::Option<::prost::alloc::string::String>,
    /// 若只改 Username，其餘欄位可不帶
    #[prost(string, repeated, tag = "2")]
    pub group:          ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub home_directory: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub shell:          ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUsersRequest {
    /// 例如 {"uid01": {"username": "..."}}
    #[prost(map = "string, message", tag = "1")]
    pub users: ::std::collections::HashMap<::prost::alloc::string::String, UserPatch>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUsersResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 刪除 User  DELETE /api/chm/user
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserRequest {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUserResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 群組資訊：Users 以 "uid.username" 字串表示
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupInfo {
    /// Groupname
    #[prost(string, tag = "1")]
    pub groupname: ::prost::alloc::string::String,
    /// \[ "uid.username", ... \]
    #[prost(string, repeated, tag = "2")]
    pub users:     ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// 取得所有群組資訊  GET /api/chm/group
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetGroupsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGroupsResponse {
    /// key = gid
    #[prost(map = "string, message", tag = "1")]
    pub groups: ::std::collections::HashMap<::prost::alloc::string::String, GroupInfo>,
}
/// 新增 Group  POST /api/chm/group
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupRequest {
    #[prost(string, tag = "1")]
    pub groupname: ::prost::alloc::string::String,
    /// \[ "uid.username", ... \]
    #[prost(string, repeated, tag = "2")]
    pub users:     ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新整筆 Group  PUT /api/chm/group
/// 請求為「gid -> GroupInfo」的映射（整筆覆蓋）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutGroupsRequest {
    /// 例如 {"gid01": {...}}
    #[prost(map = "string, message", tag = "1")]
    pub groups: ::std::collections::HashMap<::prost::alloc::string::String, GroupInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutGroupsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新 Group 單一內容  PATCH /api/chm/group
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupPatch {
    /// 目前只示範可改 Groupname
    #[prost(string, optional, tag = "1")]
    pub groupname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchGroupsRequest {
    /// 例如 {"gid01": {"groupname": "..."}}
    #[prost(map = "string, message", tag = "1")]
    pub groups: ::std::collections::HashMap<::prost::alloc::string::String, GroupPatch>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchGroupsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 刪除 Group  DELETE /api/chm/group
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupRequest {
    #[prost(string, tag = "1")]
    pub gid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGroupResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 時間排程
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Schedule {
    /// Minute
    #[prost(int64, tag = "1")]
    pub minute: i64,
    /// Hour
    #[prost(int64, tag = "2")]
    pub hour:   i64,
    /// Date
    #[prost(int64, tag = "3")]
    pub date:   i64,
    /// Month
    #[prost(int64, tag = "4")]
    pub month:  i64,
    /// Week
    #[prost(int64, tag = "5")]
    pub week:   i64,
}
/// 排程工作
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CronJobEntry {
    /// Name
    #[prost(string, tag = "1")]
    pub name:     ::prost::alloc::string::String,
    /// Command
    #[prost(string, tag = "2")]
    pub command:  ::prost::alloc::string::String,
    /// Schedule
    #[prost(message, optional, tag = "3")]
    pub schedule: ::core::option::Option<Schedule>,
    /// Username
    #[prost(string, tag = "4")]
    pub username: ::prost::alloc::string::String,
}
/// 取得所有排程表內容  GET /api/cron/all
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetCronJobsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCronJobsResponse {
    /// key = id
    #[prost(map = "string, message", tag = "1")]
    pub jobs:   ::std::collections::HashMap<::prost::alloc::string::String, CronJobEntry>,
    /// jobs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 新增資料  POST /api/cron
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCronRequest {
    #[prost(message, optional, tag = "1")]
    pub job: ::core::option::Option<CronJobEntry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCronResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 刪除  DELETE /api/cron
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCronRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCronResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 更新（整筆覆蓋，支援多筆） PUT /api/cron
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutCronRequest {
    /// {"id01": {...}, ...}
    #[prost(map = "string, message", tag = "1")]
    pub items: ::std::collections::HashMap<::prost::alloc::string::String, CronJobEntry>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutCronResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 匯入  POST /api/cron/action/import
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CronFile {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    /// 檔案內容
    #[prost(bytes = "vec", tag = "2")]
    pub content:  ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCronRequest {
    /// 規格為單一檔案；若未來要多檔可改 repeated
    #[prost(message, optional, tag = "1")]
    pub file: ::core::option::Option<CronFile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCronResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 匯出  POST /api/cron/action/export
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportCronRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportCronResponse {
    #[prost(message, optional, tag = "1")]
    pub result:   ::core::option::Option<super::common::ResponseResult>,
    /// 規格中的 "Message": file；為了實用性補充實際檔案欄位
    ///
    /// 例如 "crontab.txt"
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    /// 匯出檔案內容
    #[prost(bytes = "vec", tag = "3")]
    pub file:     ::prost::alloc::vec::Vec<u8>,
}
/// 取得所有主機 GET /api/file/pdir/pcs
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPdirPcsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPdirPcsResponse {
    /// key = uuid, value = hostname
    #[prost(map = "string, string", tag = "1")]
    pub pcs:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 取得單一主機資料夾 GET /api/file/pdir/one
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPdirOneRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid:      ::prost::alloc::string::String,
    /// 目錄（預設根目錄，可傳空字串代表 root）
    #[prost(string, tag = "2")]
    pub directory: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileEntry {
    /// Size
    #[prost(double, tag = "1")]
    pub size:     f64,
    /// Unit
    #[prost(enumeration = "FileUnit", tag = "2")]
    pub unit:     i32,
    /// Owner
    #[prost(string, tag = "3")]
    pub owner:    ::prost::alloc::string::String,
    /// Mode
    #[prost(string, tag = "4")]
    pub mode:     ::prost::alloc::string::String,
    /// Modified（文字時間）
    #[prost(string, tag = "5")]
    pub modified: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPdirOneResponse {
    /// key = filename
    #[prost(map = "string, message", tag = "1")]
    pub files:  ::std::collections::HashMap<::prost::alloc::string::String, FileEntry>,
    /// files.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 上傳檔案（指定 PC）POST /api/file/pdir/action/upload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileBlob {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
    /// 檔案內容
    #[prost(bytes = "vec", tag = "2")]
    pub content:  ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadPdirFilesRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
    /// 可多檔
    #[prost(message, repeated, tag = "2")]
    pub file: ::prost::alloc::vec::Vec<FileBlob>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadPdirFilesResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 下載檔案 POST /api/file/pdir/action/download
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadPdirFileRequest {
    #[prost(string, tag = "1")]
    pub uuid:     ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadPdirFileResponse {
    #[prost(message, optional, tag = "1")]
    pub result:   ::core::option::Option<super::common::ResponseResult>,
    /// 便利起見一併回傳檔名
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    /// 檔案內容
    #[prost(bytes = "vec", tag = "3")]
    pub file:     ::prost::alloc::vec::Vec<u8>,
}
/// 取得虛擬目錄 GET /api/file/vdir
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVdirPathRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVdirPathResponse {
    /// 目前虛擬目錄路徑
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
}
/// 上傳檔案（for all PC）POST /api/file/vdir/action/upload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadVdirFilesRequest {
    /// 可多檔
    #[prost(message, repeated, tag = "1")]
    pub file: ::prost::alloc::vec::Vec<FileBlob>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadVdirFilesResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ResponseResult>,
}
/// 下載檔案 POST /api/file/vdir/action/download
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadVdirFileRequest {
    #[prost(string, tag = "1")]
    pub filename: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DownloadVdirFileResponse {
    #[prost(message, optional, tag = "1")]
    pub result:   ::core::option::Option<super::common::ResponseResult>,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub file:     ::prost::alloc::vec::Vec<u8>,
}
/// 時間物件（系統日誌 /all 回傳使用）
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SysLogTime {
    /// Hour
    #[prost(int64, tag = "1")]
    pub hour: i64,
    /// Min
    #[prost(int64, tag = "2")]
    pub min:  i64,
}
/// 系統日誌條目（/api/logs/sys，用物件時間）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SysLogEntry {
    /// Month
    #[prost(string, tag = "1")]
    pub month:     ::prost::alloc::string::String,
    /// Day
    #[prost(int64, tag = "2")]
    pub day:       i64,
    /// Time.{Hour, Min}
    #[prost(message, optional, tag = "3")]
    pub time:      ::core::option::Option<SysLogTime>,
    /// Direction（A to B）
    #[prost(string, tag = "4")]
    pub direction: ::prost::alloc::string::String,
    /// Type
    #[prost(string, tag = "5")]
    pub r#type:    ::prost::alloc::string::String,
    /// Messages
    #[prost(string, tag = "6")]
    pub messages:  ::prost::alloc::string::String,
}
/// 系統日誌條目（/api/logs/sys/query，時間為字串）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SysLogEntryFlat {
    /// Month
    #[prost(string, tag = "1")]
    pub month:     ::prost::alloc::string::String,
    /// Day
    #[prost(int64, tag = "2")]
    pub day:       i64,
    /// Time（字串）
    #[prost(string, tag = "3")]
    pub time:      ::prost::alloc::string::String,
    /// Direction
    #[prost(string, tag = "4")]
    pub direction: ::prost::alloc::string::String,
    /// Type
    #[prost(string, tag = "5")]
    pub r#type:    ::prost::alloc::string::String,
    /// Messages
    #[prost(string, tag = "6")]
    pub messages:  ::prost::alloc::string::String,
}
/// 取得所有系統日誌  GET /api/logs/sys
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSysLogsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSysLogsResponse {
    /// key = id
    #[prost(map = "string, message", tag = "1")]
    pub logs:   ::std::collections::HashMap<::prost::alloc::string::String, SysLogEntry>,
    /// logs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 查詢條件
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SysLogsTypes {}
/// Nested message and enum types in `SysLogsTypes`.
pub mod sys_logs_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SysLogSearchField {
        Unspecified = 0,
        Month = 1,
        Day = 2,
        Time = 3,
        Direction = 4,
        Type = 5,
    }
    impl SysLogSearchField {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYS_LOG_SEARCH_FIELD_UNSPECIFIED",
                Self::Month => "MONTH",
                Self::Day => "DAY",
                Self::Time => "TIME",
                Self::Direction => "DIRECTION",
                Self::Type => "TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYS_LOG_SEARCH_FIELD_UNSPECIFIED" => Some(Self::Unspecified),
                "MONTH" => Some(Self::Month),
                "DAY" => Some(Self::Day),
                "TIME" => Some(Self::Time),
                "DIRECTION" => Some(Self::Direction),
                "TYPE" => Some(Self::Type),
                _ => None,
            }
        }
    }
}
/// 篩選條件取得系統日誌  GET /api/logs/sys/query
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySysLogsRequest {
    /// "Month" | "Day" | "Time" | "Direction" | "Type"
    #[prost(enumeration = "sys_logs_types::SysLogSearchField", tag = "1")]
    pub search:    i32,
    /// 對應的參數值（字串）
    #[prost(string, tag = "2")]
    pub parameter: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySysLogsResponse {
    /// key = id
    #[prost(map = "string, message", tag = "1")]
    pub logs:   ::std::collections::HashMap<::prost::alloc::string::String, SysLogEntryFlat>,
    /// logs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 取得所有主機（供選擇） GET /api/logs/pc/all
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetPcLogPcsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPcLogPcsResponse {
    /// key = uuid, value = hostname
    #[prost(map = "string, string", tag = "1")]
    pub pcs:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 個別被控端日誌條目（時間為字串）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcLogEntry {
    /// Month
    #[prost(string, tag = "1")]
    pub month:    ::prost::alloc::string::String,
    /// Day
    #[prost(int64, tag = "2")]
    pub day:      i64,
    /// Time（字串）
    #[prost(string, tag = "3")]
    pub time:     ::prost::alloc::string::String,
    /// Hostname
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    /// Type
    #[prost(string, tag = "5")]
    pub r#type:   ::prost::alloc::string::String,
    /// Messages
    #[prost(string, tag = "6")]
    pub messages: ::prost::alloc::string::String,
}
/// 取得個別被控端日誌  GET /api/logs/pc
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPcLogsRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPcLogsResponse {
    /// key = id
    #[prost(map = "string, message", tag = "1")]
    pub logs:   ::std::collections::HashMap<::prost::alloc::string::String, PcLogEntry>,
    /// logs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 查詢條件
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PcLogsTypes {}
/// Nested message and enum types in `PcLogsTypes`.
pub mod pc_logs_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PcLogSearchField {
        Unspecified = 0,
        Month = 1,
        Day = 2,
        Time = 3,
        Hostname = 4,
        Type = 5,
    }
    impl PcLogSearchField {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PC_LOG_SEARCH_FIELD_UNSPECIFIED",
                Self::Month => "MONTH",
                Self::Day => "DAY",
                Self::Time => "TIME",
                Self::Hostname => "HOSTNAME",
                Self::Type => "TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PC_LOG_SEARCH_FIELD_UNSPECIFIED" => Some(Self::Unspecified),
                "MONTH" => Some(Self::Month),
                "DAY" => Some(Self::Day),
                "TIME" => Some(Self::Time),
                "HOSTNAME" => Some(Self::Hostname),
                "TYPE" => Some(Self::Type),
                _ => None,
            }
        }
    }
}
/// 篩選條件取得個別被控端日誌  GET /api/logs/pc/query
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPcLogsRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid:      ::prost::alloc::string::String,
    /// "Month" | "Day" | "Time" | "Hostname" | "Type"
    #[prost(enumeration = "pc_logs_types::PcLogSearchField", tag = "2")]
    pub search:    i32,
    /// 對應的參數值（字串）
    #[prost(string, tag = "3")]
    pub parameter: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPcLogsResponse {
    /// key = id
    #[prost(map = "string, message", tag = "1")]
    pub logs:   ::std::collections::HashMap<::prost::alloc::string::String, PcLogEntry>,
    /// logs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 取得所有主機  GET /api/firewall/pcs
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetFirewallPcsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallPcsResponse {
    /// key = uuid, value = hostname
    #[prost(map = "string, string", tag = "1")]
    pub pcs:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// 規則
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    /// Target
    #[prost(enumeration = "Verdict", tag = "1")]
    pub target:      i32,
    /// Protocol
    #[prost(string, tag = "2")]
    pub protocol:    ::prost::alloc::string::String,
    /// In
    #[prost(string, tag = "3")]
    pub in_if:       ::prost::alloc::string::String,
    /// Out
    #[prost(string, tag = "4")]
    pub out_if:      ::prost::alloc::string::String,
    /// Source
    #[prost(string, tag = "5")]
    pub source:      ::prost::alloc::string::String,
    /// Destination
    #[prost(string, tag = "6")]
    pub destination: ::prost::alloc::string::String,
    /// Options
    #[prost(string, tag = "7")]
    pub options:     ::prost::alloc::string::String,
}
/// 鏈（含預設策略與規則）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chain {
    /// INPUT / FORWARD / OUTPUT
    #[prost(string, tag = "1")]
    pub name:         ::prost::alloc::string::String,
    /// 預設策略
    #[prost(enumeration = "Verdict", tag = "2")]
    pub policy:       i32,
    #[prost(message, repeated, tag = "3")]
    pub rules:        ::prost::alloc::vec::Vec<Rule>,
    /// rules.len
    #[prost(uint64, tag = "4")]
    pub rules_length: u64,
}
/// 取得單一防火牆狀態  GET /api/firewall
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallRequest {
    /// 主機 ID
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallResponse {
    /// active / inactive
    #[prost(enumeration = "FirewallStatus", tag = "1")]
    pub status: i32,
    #[prost(message, repeated, tag = "2")]
    pub chains: ::prost::alloc::vec::Vec<Chain>,
}
/// 新增防火牆規則  POST /api/firewall/rule
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddFirewallRuleRequest {
    /// 主機 ID
    #[prost(string, tag = "1")]
    pub uuid:        ::prost::alloc::string::String,
    /// INPUT | FORWARD | OUTPUT
    #[prost(enumeration = "ChainKind", tag = "2")]
    pub chain:       i32,
    /// ACCEPT | DROP | REJECT
    #[prost(enumeration = "Verdict", tag = "3")]
    pub target:      i32,
    #[prost(string, tag = "4")]
    pub protocol:    ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub in_if:       ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub out_if:      ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub source:      ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub options:     ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddFirewallRuleResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 刪除防火牆規則  DELETE /api/firewall/rule
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallRuleRequest {
    /// 主機 ID
    #[prost(string, tag = "1")]
    pub uuid:    ::prost::alloc::string::String,
    /// INPUT | FORWARD | OUTPUT
    #[prost(enumeration = "ChainKind", tag = "2")]
    pub chain:   i32,
    /// 規則索引
    #[prost(uint64, tag = "3")]
    pub rule_id: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallRuleResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 修改防火牆狀態（啟用/停用） PUT /api/firewall/status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutFirewallStatusRequest {
    #[prost(string, tag = "1")]
    pub uuid:   ::prost::alloc::string::String,
    /// active / inactive
    #[prost(enumeration = "FirewallStatus", tag = "2")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutFirewallStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 修改預設策略（Policy） PUT /api/firewall/policy
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutFirewallPolicyRequest {
    #[prost(string, tag = "1")]
    pub uuid:   ::prost::alloc::string::String,
    /// INPUT | FORWARD | OUTPUT
    #[prost(enumeration = "ChainKind", tag = "2")]
    pub chain:  i32,
    /// ACCEPT | DROP | REJECT
    #[prost(enumeration = "Verdict", tag = "3")]
    pub policy: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutFirewallPolicyResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkItem {
    /// Type (Virtual/Physical)
    #[prost(enumeration = "NicType", tag = "1")]
    pub r#type:    i32,
    /// Ipv4
    #[prost(string, tag = "2")]
    pub ipv4:      ::prost::alloc::string::String,
    /// Netmask
    #[prost(string, tag = "3")]
    pub netmask:   ::prost::alloc::string::String,
    /// Mac
    #[prost(string, tag = "4")]
    pub mac:       ::prost::alloc::string::String,
    /// Broadcast
    #[prost(string, tag = "5")]
    pub broadcast: ::prost::alloc::string::String,
    /// Mtu
    #[prost(int64, tag = "6")]
    pub mtu:       i64,
    /// Status (Up/Down)
    #[prost(enumeration = "NicStatus", tag = "7")]
    pub status:    i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcNetworks {
    /// key = nid
    #[prost(map = "string, message", tag = "1")]
    pub networks: ::std::collections::HashMap<::prost::alloc::string::String, NetworkItem>,
    /// networks.len
    #[prost(uint64, tag = "2")]
    pub length:   u64,
}
/// GET /api/network/net
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllNetRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllNetResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcNetworks>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// POST /api/network/net
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNetRequest {
    /// Nid
    #[prost(string, tag = "1")]
    pub nid:       ::prost::alloc::string::String,
    /// Type
    #[prost(enumeration = "NicType", tag = "2")]
    pub r#type:    i32,
    /// Ipv4
    #[prost(string, tag = "3")]
    pub ipv4:      ::prost::alloc::string::String,
    /// Netmask
    #[prost(string, tag = "4")]
    pub netmask:   ::prost::alloc::string::String,
    /// Mac
    #[prost(string, tag = "5")]
    pub mac:       ::prost::alloc::string::String,
    /// Broadcast
    #[prost(string, tag = "6")]
    pub broadcast: ::prost::alloc::string::String,
    /// Mtu
    #[prost(int64, tag = "7")]
    pub mtu:       i64,
    /// Status
    #[prost(enumeration = "NicStatus", tag = "8")]
    pub status:    i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNetResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// DELETE /api/network/net
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetRequest {
    #[prost(string, tag = "1")]
    pub nid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// PATCH /api/network/net  (單一欄位更新：僅帶需要的欄位)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetRequest {
    #[prost(string, tag = "1")]
    pub nid:       ::prost::alloc::string::String,
    /// 任一欄位可選，其餘留白
    #[prost(string, tag = "2")]
    pub ipv4:      ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub netmask:   ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub mac:       ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub broadcast: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub mtu:       i64,
    #[prost(enumeration = "NicStatus", tag = "7")]
    pub status:    i32,
    #[prost(enumeration = "NicType", tag = "8")]
    pub r#type:    i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// PUT /api/network/net  (整筆覆蓋)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutNetRequest {
    #[prost(string, tag = "1")]
    pub nid:       ::prost::alloc::string::String,
    #[prost(enumeration = "NicType", tag = "2")]
    pub r#type:    i32,
    #[prost(string, tag = "3")]
    pub ipv4:      ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub netmask:   ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub mac:       ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub broadcast: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub mtu:       i64,
    #[prost(enumeration = "NicStatus", tag = "8")]
    pub status:    i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutNetResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/network/net/action/up
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetUpRequest {
    #[prost(string, tag = "1")]
    pub nid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetUpResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/network/net/action/down
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetDownRequest {
    #[prost(string, tag = "1")]
    pub nid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetDownResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteItem {
    /// Via
    #[prost(string, tag = "1")]
    pub via:    ::prost::alloc::string::String,
    /// Dev
    #[prost(string, tag = "2")]
    pub dev:    ::prost::alloc::string::String,
    /// Proto
    #[prost(string, tag = "3")]
    pub proto:  ::prost::alloc::string::String,
    /// Metric
    #[prost(int64, tag = "4")]
    pub metric: i64,
    /// Scope
    #[prost(string, tag = "5")]
    pub scope:  ::prost::alloc::string::String,
    /// Src
    #[prost(string, tag = "6")]
    pub src:    ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcRoutes {
    /// key = destination
    #[prost(map = "string, message", tag = "1")]
    pub routes: ::std::collections::HashMap<::prost::alloc::string::String, RouteItem>,
    /// routes.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// GET /api/network/route
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllRouteRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllRouteResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcRoutes>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// POST /api/network/route
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRouteRequest {
    #[prost(string, tag = "1")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub via:         ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dev:         ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub proto:       ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub metric:      i64,
    #[prost(string, tag = "6")]
    pub scope:       ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub src:         ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRouteResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// DELETE /api/network/route
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRouteRequest {
    #[prost(string, tag = "1")]
    pub destination: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRouteResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRouteRequest {
    #[prost(string, tag = "1")]
    pub destination: ::prost::alloc::string::String,
    /// 要更新的欄位
    #[prost(enumeration = "RouteField", tag = "2")]
    pub field:       i32,
    /// 值（僅提供對應欄位）
    #[prost(string, tag = "3")]
    pub via:         ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub dev:         ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub proto:       ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub metric:      i64,
    #[prost(string, tag = "7")]
    pub scope:       ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub src:         ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRouteResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// PUT /api/network/route （整筆覆蓋）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRouteRequest {
    #[prost(string, tag = "1")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub via:         ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dev:         ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub proto:       ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub metric:      i64,
    #[prost(string, tag = "6")]
    pub scope:       ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub src:         ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutRouteResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsPair {
    /// Primary
    #[prost(string, tag = "1")]
    pub primary:   ::prost::alloc::string::String,
    /// Secondary
    #[prost(string, tag = "2")]
    pub secondary: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcDns {
    /// Hostname
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    /// DNS
    #[prost(message, optional, tag = "2")]
    pub dns:      ::core::option::Option<DnsPair>,
}
/// GET /api/network/dns
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllDnsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllDnsResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs: ::std::collections::HashMap<::prost::alloc::string::String, PcDns>,
}
/// PATCH /api/network/dns  (更改 Hostname：只提供目標 uuid)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchHostnameRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchHostnameResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// PUT /api/network/dns  (更改 DNS Server IP)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutDnsRequest {
    #[prost(string, tag = "1")]
    pub primary:   ::prost::alloc::string::String,
    /// 若未提供，伺服端可沿用舊值
    #[prost(string, tag = "2")]
    pub secondary: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutDnsResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 進程資訊
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProcessEntry {
    /// 是否運行中
    #[prost(bool, tag = "1")]
    pub status: bool,
    /// 是否開機自動啟動
    #[prost(bool, tag = "2")]
    pub boot:   bool,
}
/// /api/process/all ─ 取得所有電腦的 Process
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetAllProcessRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcProcess {
    /// 該台主機的 Hostname
    #[prost(string, tag = "1")]
    pub hostname:  ::prost::alloc::string::String,
    /// key = pname
    #[prost(map = "string, message", tag = "2")]
    pub processes: ::std::collections::HashMap<::prost::alloc::string::String, ProcessEntry>,
    /// process.len
    #[prost(uint64, tag = "3")]
    pub length:    u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllProcessResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs:    ::std::collections::HashMap<::prost::alloc::string::String, PcProcess>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// /api/process/one ─ 取得單一電腦的 Process
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOneProcessRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOneProcessResponse {
    /// key = pname
    #[prost(map = "string, message", tag = "1")]
    pub processes: ::std::collections::HashMap<::prost::alloc::string::String, ProcessEntry>,
    /// process.len
    #[prost(uint64, tag = "2")]
    pub length:    u64,
}
/// 動作請求共用
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessActionRequest {
    #[prost(string, tag = "1")]
    pub uuid:    ::prost::alloc::string::String,
    /// pname
    #[prost(string, tag = "2")]
    pub process: ::prost::alloc::string::String,
}
/// 動作回應統一使用 common.ActionResult（含 {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/enable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/disable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/start_enable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEnableProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartEnableProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/process/action/stop_disable
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopDisableProcessRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ProcessActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopDisableProcessResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 套件資訊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageInfo {
    /// Version
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Status
    #[prost(enumeration = "PackageStatus", tag = "2")]
    pub status:  i32,
}
/// 單一 PC 的套件清單
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcPackages {
    /// key = package name
    #[prost(map = "string, message", tag = "1")]
    pub packages: ::std::collections::HashMap<::prost::alloc::string::String, PackageInfo>,
}
/// 取得軟體清單 GET /api/software
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSoftwareRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSoftwareResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs: ::std::collections::HashMap<::prost::alloc::string::String, PcPackages>,
}
/// 安裝軟體套件 POST /api/software
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallSoftwareRequest {
    /// Uuid
    #[prost(string, repeated, tag = "1")]
    pub uuids:    ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Packages
    #[prost(string, repeated, tag = "2")]
    pub packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// 刪除軟體套件 DELETE /api/software
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSoftwareRequest {
    /// Uuid
    #[prost(string, repeated, tag = "1")]
    pub uuids:    ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Package
    #[prost(string, repeated, tag = "2")]
    pub packages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// 安裝/刪除結果彙總
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageActionResult {
    /// Installed: \[uuid\]
    #[prost(string, repeated, tag = "1")]
    pub installed:    ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Notinstalled: \[uuid\]
    #[prost(string, repeated, tag = "2")]
    pub notinstalled: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageActionResponse {
    /// key = package name
    #[prost(map = "string, message", tag = "1")]
    pub packages: ::std::collections::HashMap<::prost::alloc::string::String, PackageActionResult>,
    /// packages.len
    #[prost(uint64, tag = "2")]
    pub length:   u64,
}
/// GET /api/server/apache
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApacheRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Access Log 條目
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApacheAccessLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:         ::prost::alloc::string::String,
    /// Date（含 Year / Month / Week / Time{Hour,Min}）
    #[prost(message, optional, tag = "2")]
    pub date:       ::core::option::Option<super::common::Date>,
    /// Method（GET/POST...）
    #[prost(string, tag = "3")]
    pub method:     ::prost::alloc::string::String,
    /// URL
    #[prost(string, tag = "4")]
    pub url:        ::prost::alloc::string::String,
    /// Protocol
    #[prost(string, tag = "5")]
    pub protocol:   ::prost::alloc::string::String,
    /// HTTP 狀態碼
    #[prost(int64, tag = "6")]
    pub status:     i64,
    /// 回應大小
    #[prost(int64, tag = "7")]
    pub byte:       i64,
    /// Referer
    #[prost(string, tag = "8")]
    pub referer:    ::prost::alloc::string::String,
    /// User_Agent
    #[prost(string, tag = "9")]
    pub user_agent: ::prost::alloc::string::String,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApacheLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log:  ::prost::alloc::vec::Vec<super::common::ErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength:  u64,
    /// Access_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub access_log: ::prost::alloc::vec::Vec<ApacheAccessLog>,
    /// Access_log.len
    #[prost(uint64, tag = "4")]
    pub acclength:  u64,
}
/// 回傳（以 common.CommonInfo 承載 Hostname/Status/Cpu/Memory）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetApacheResponse {
    /// { hostname, status(active|stopped), cpu, memory }
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 目前連線數
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// 錯誤與存取日誌
    #[prost(message, optional, tag = "3")]
    pub logs:        ::core::option::Option<ApacheLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApacheActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApacheActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 具名動作端點（對應 REST 路由）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartApacheRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ApacheActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartApacheResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopApacheRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ApacheActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopApacheResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartApacheRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<ApacheActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartApacheResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控 GET /api/server/bind
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBindRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 統計資料（Queries）
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BindQueries {
    /// Total：總查詢次數
    #[prost(int64, tag = "1")]
    pub total:    i64,
    /// Success：成功解析次數
    #[prost(int64, tag = "2")]
    pub success:  i64,
    /// NXDOMAIN：無此網域次數
    #[prost(int64, tag = "3")]
    pub nxdomain: i64,
    /// REFUSED：拒絕回應次數
    #[prost(int64, tag = "4")]
    pub refused:  i64,
}
/// 單筆 Query_log
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindQueryLog {
    /// Client（IP:Port）
    #[prost(string, tag = "1")]
    pub client:   ::prost::alloc::string::String,
    /// Date
    #[prost(message, optional, tag = "2")]
    pub date:     ::core::option::Option<super::common::Date>,
    /// 查詢網域
    #[prost(string, tag = "3")]
    pub query:    ::prost::alloc::string::String,
    /// 查詢類型
    #[prost(enumeration = "DnsQueryType", tag = "4")]
    pub r#type:   i32,
    /// 回應（IP/紀錄）
    #[prost(string, tag = "5")]
    pub response: ::prost::alloc::string::String,
    /// 回應狀態
    #[prost(enumeration = "DnsQueryStatus", tag = "6")]
    pub status:   i32,
    /// 查詢時間（毫秒）
    #[prost(double, tag = "7")]
    pub duration: f64,
}
/// Logs 區塊（含 Error_log 與 Query_log）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log: ::prost::alloc::vec::Vec<super::common::ErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength: u64,
    /// Query_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub query_log: ::prost::alloc::vec::Vec<BindQueryLog>,
    /// Query_log.len
    #[prost(uint64, tag = "4")]
    pub qrylength: u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBindResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 目前處理的請求數量
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// 統計
    #[prost(message, optional, tag = "3")]
    pub queries:     ::core::option::Option<BindQueries>,
    /// 日誌
    #[prost(message, optional, tag = "4")]
    pub logs:        ::core::option::Option<BindLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BindActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/bind/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartBindRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<BindActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartBindResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/bind/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopBindRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<BindActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopBindResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/bind/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartBindRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<BindActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartBindResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控 GET /api/server/ldap
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLdapRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 單筆 Access_log
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LdapAccessLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:               ::prost::alloc::string::String,
    /// Date
    #[prost(message, optional, tag = "2")]
    pub date:             ::core::option::Option<super::common::Date>,
    /// BIND/SEARCH/...
    #[prost(enumeration = "LdapMethod", tag = "3")]
    pub method:           i32,
    /// Base_DN
    #[prost(string, tag = "4")]
    pub base_dn:          ::prost::alloc::string::String,
    /// Filter（SEARCH 相關）
    #[prost(string, tag = "5")]
    pub filter:           ::prost::alloc::string::String,
    /// LDAPv2/LDAPv3
    #[prost(enumeration = "LdapProtocol", tag = "6")]
    pub protocol:         i32,
    /// Success/AuthFailed/NotFound/Error
    #[prost(enumeration = "LdapOpStatus", tag = "7")]
    pub status:           i32,
    /// 操作耗時（毫秒）
    #[prost(int64, tag = "8")]
    pub response_time_ms: i64,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LdapLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log:  ::prost::alloc::vec::Vec<super::common::ErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength:  u64,
    /// Access_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub access_log: ::prost::alloc::vec::Vec<LdapAccessLog>,
    /// Access_log.len
    #[prost(uint64, tag = "4")]
    pub acclength:  u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLdapResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 目前連線數
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// 目前 LDAP 內條目數
    #[prost(int64, tag = "3")]
    pub entries:     i64,
    /// 日誌
    #[prost(message, optional, tag = "4")]
    pub logs:        ::core::option::Option<LdapLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LdapActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LdapActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ldap/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartLdapRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<LdapActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartLdapResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ldap/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopLdapRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<LdapActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopLdapResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ldap/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartLdapRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<LdapActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartLdapResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控 GET /api/server/mysql
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMySqlRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 查詢類型與結果枚舉
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MySqlTypes {}
/// Nested message and enum types in `MySqlTypes`.
pub mod my_sql_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MySqlQueryType {
        MysqlQueryTypeUnspecified = 0,
        Select = 1,
        Insert = 2,
        Update = 3,
        Delete = 4,
        Create = 5,
        Drop = 6,
        Alter = 7,
    }
    impl MySqlQueryType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MysqlQueryTypeUnspecified => "MYSQL_QUERY_TYPE_UNSPECIFIED",
                Self::Select => "SELECT",
                Self::Insert => "INSERT",
                Self::Update => "UPDATE",
                Self::Delete => "DELETE",
                Self::Create => "CREATE",
                Self::Drop => "DROP",
                Self::Alter => "ALTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MYSQL_QUERY_TYPE_UNSPECIFIED" => Some(Self::MysqlQueryTypeUnspecified),
                "SELECT" => Some(Self::Select),
                "INSERT" => Some(Self::Insert),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "CREATE" => Some(Self::Create),
                "DROP" => Some(Self::Drop),
                "ALTER" => Some(Self::Alter),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum MySqlQueryStatus {
        MysqlQueryStatusUnspecified = 0,
        Success = 1,
        Error = 2,
        Timeout = 3,
    }
    impl MySqlQueryStatus {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MysqlQueryStatusUnspecified => "MYSQL_QUERY_STATUS_UNSPECIFIED",
                Self::Success => "SUCCESS",
                Self::Error => "ERROR",
                Self::Timeout => "TIMEOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MYSQL_QUERY_STATUS_UNSPECIFIED" => Some(Self::MysqlQueryStatusUnspecified),
                "SUCCESS" => Some(Self::Success),
                "ERROR" => Some(Self::Error),
                "TIMEOUT" => Some(Self::Timeout),
                _ => None,
            }
        }
    }
}
/// 單筆 Query_log
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlQueryLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:            ::prost::alloc::string::String,
    /// Date（含 Week/Month/Day/Time{Hour,Min}）
    #[prost(message, optional, tag = "2")]
    pub date:          ::core::option::Option<super::common::Date>,
    /// 執行查詢的使用者
    #[prost(string, tag = "3")]
    pub user:          ::prost::alloc::string::String,
    /// 資料庫名稱
    #[prost(string, tag = "4")]
    pub database:      ::prost::alloc::string::String,
    /// SQL
    #[prost(string, tag = "5")]
    pub query:         ::prost::alloc::string::String,
    /// SELECT/INSERT/...
    #[prost(enumeration = "my_sql_types::MySqlQueryType", tag = "6")]
    pub query_type:    i32,
    /// 毫秒
    #[prost(int64, tag = "7")]
    pub duration_ms:   i64,
    /// Success/Error/Timeout
    #[prost(enumeration = "my_sql_types::MySqlQueryStatus", tag = "8")]
    pub status:        i32,
    /// 影響列數
    #[prost(int64, tag = "9")]
    pub affected_rows: i64,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log:   ::prost::alloc::vec::Vec<super::common::ErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength:   u64,
    /// Query_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub query_log:   ::prost::alloc::vec::Vec<MySqlQueryLog>,
    /// Query_log.len
    #[prost(uint64, tag = "4")]
    pub querylength: u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMySqlResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info:     ::core::option::Option<super::common::CommonInfo>,
    /// 活躍連線數
    #[prost(int64, tag = "2")]
    pub connections:     i64,
    /// 資料庫數量
    #[prost(int64, tag = "3")]
    pub databases:       i64,
    /// QPS
    #[prost(double, tag = "4")]
    pub queries_per_sec: f64,
    /// 日誌
    #[prost(message, optional, tag = "5")]
    pub logs:            ::core::option::Option<MySqlLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/mysql/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartMySqlRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<MySqlActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartMySqlResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/mysql/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopMySqlRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<MySqlActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopMySqlResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/mysql/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartMySqlRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<MySqlActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartMySqlResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控 GET /api/server/nginx
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNginxRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 連線統計
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NginxConnections {
    /// Active：當前活動連線數
    #[prost(int64, tag = "1")]
    pub active:   i64,
    /// Accepted：累計接受連線數
    #[prost(int64, tag = "2")]
    pub accepted: i64,
    /// Handled：實際處理連線數
    #[prost(int64, tag = "3")]
    pub handled:  i64,
    /// Requests：總請求數
    #[prost(int64, tag = "4")]
    pub requests: i64,
}
/// Nginx Error Log（擴充：包含 Worker_Id）
/// 備註：為了保留通用欄位定義，這裡以巢狀承載 common.ErrorLog；若要與前端 JSON
/// 扁平鍵一一對應，實作端可在序列化時展開。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NginxErrorLog {
    /// Worker_Id
    #[prost(int64, tag = "1")]
    pub worker_id: i64,
    /// 原本的 {Date, Module, Level, Pid, Client, Message}
    #[prost(message, optional, tag = "2")]
    pub base:      ::core::option::Option<super::common::ErrorLog>,
}
/// Access_log 條目
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NginxAccessLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:                     ::prost::alloc::string::String,
    /// Date（含 Week/Month/Day/Time{Hour,Min}）
    #[prost(message, optional, tag = "2")]
    pub date:                   ::core::option::Option<super::common::Date>,
    /// 請求方法（GET/POST…）
    #[prost(string, tag = "3")]
    pub method:                 ::prost::alloc::string::String,
    /// 請求 URL
    #[prost(string, tag = "4")]
    pub url:                    ::prost::alloc::string::String,
    /// 協議版本
    #[prost(string, tag = "5")]
    pub protocol:               ::prost::alloc::string::String,
    /// HTTP 狀態碼
    #[prost(int64, tag = "6")]
    pub status:                 i64,
    /// 回應大小
    #[prost(int64, tag = "7")]
    pub byte:                   i64,
    /// 來源網站
    #[prost(string, tag = "8")]
    pub referer:                ::prost::alloc::string::String,
    /// 使用者代理
    #[prost(string, tag = "9")]
    pub user_agent:             ::prost::alloc::string::String,
    /// 反向代理後端位址
    #[prost(string, tag = "10")]
    pub upstream:               ::prost::alloc::string::String,
    /// 處理請求時間（秒）
    #[prost(double, tag = "11")]
    pub request_time:           f64,
    /// 後端回應時間（秒）
    #[prost(double, tag = "12")]
    pub upstream_response_time: f64,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NginxLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log:  ::prost::alloc::vec::Vec<NginxErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength:  u64,
    /// Access_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub access_log: ::prost::alloc::vec::Vec<NginxAccessLog>,
    /// Access_log.len
    #[prost(uint64, tag = "4")]
    pub acclength:  u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNginxResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 連線統計
    #[prost(message, optional, tag = "2")]
    pub connections: ::core::option::Option<NginxConnections>,
    /// 日誌
    #[prost(message, optional, tag = "3")]
    pub logs:        ::core::option::Option<NginxLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NginxActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NginxActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/nginx/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNginxRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<NginxActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNginxResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/nginx/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNginxRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<NginxActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNginxResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/nginx/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartNginxRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<NginxActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartNginxResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控 GET /api/server/ftp
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFtpRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Session 狀態
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FtpTypes {}
/// Nested message and enum types in `FtpTypes`.
pub mod ftp_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FtpSessionStatus {
        Unspecified = 0,
        Idle = 1,
        Uploading = 2,
        Downloading = 3,
        Disconnected = 4,
    }
    impl FtpSessionStatus {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FTP_SESSION_STATUS_UNSPECIFIED",
                Self::Idle => "IDLE",
                Self::Uploading => "UPLOADING",
                Self::Downloading => "DOWNLOADING",
                Self::Disconnected => "DISCONNECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FTP_SESSION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "IDLE" => Some(Self::Idle),
                "UPLOADING" => Some(Self::Uploading),
                "DOWNLOADING" => Some(Self::Downloading),
                "DISCONNECTED" => Some(Self::Disconnected),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FtpTransferType {
        Unspecified = 0,
        Upload = 1,
        Download = 2,
    }
    impl FtpTransferType {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FTP_TRANSFER_TYPE_UNSPECIFIED",
                Self::Upload => "UPLOAD",
                Self::Download => "DOWNLOAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FTP_TRANSFER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "UPLOAD" => Some(Self::Upload),
                "DOWNLOAD" => Some(Self::Download),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FtpAccessAction {
        Unspecified = 0,
        Login = 1,
        Logout = 2,
        UploadAction = 3,
        DownloadAction = 4,
        Delete = 5,
        Rename = 6,
    }
    impl FtpAccessAction {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FTP_ACCESS_ACTION_UNSPECIFIED",
                Self::Login => "LOGIN",
                Self::Logout => "LOGOUT",
                Self::UploadAction => "UPLOAD_ACTION",
                Self::DownloadAction => "DOWNLOAD_ACTION",
                Self::Delete => "DELETE",
                Self::Rename => "RENAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FTP_ACCESS_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "LOGIN" => Some(Self::Login),
                "LOGOUT" => Some(Self::Logout),
                "UPLOAD_ACTION" => Some(Self::UploadAction),
                "DOWNLOAD_ACTION" => Some(Self::DownloadAction),
                "DELETE" => Some(Self::Delete),
                "RENAME" => Some(Self::Rename),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum FtpAccessStatus {
        Unspecified = 0,
        Success = 1,
        Failed = 2,
    }
    impl FtpAccessStatus {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FTP_ACCESS_STATUS_UNSPECIFIED",
                Self::Success => "SUCCESS",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FTP_ACCESS_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCESS" => Some(Self::Success),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Session 登入時間
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FtpLoginTime {
    /// Year
    #[prost(int64, tag = "1")]
    pub year:  i64,
    /// Month
    #[prost(enumeration = "ftp_login_time::Month", tag = "2")]
    pub month: i32,
    /// Day
    #[prost(int64, tag = "3")]
    pub day:   i64,
    /// Hour
    #[prost(int64, tag = "4")]
    pub hour:  i64,
    /// Min
    #[prost(int64, tag = "5")]
    pub min:   i64,
}
/// Nested message and enum types in `FtpLoginTime`.
pub mod ftp_login_time {
    /// Month / Day / Hour / Min 與前端 JSON 對應
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Month {
        Unspecified = 0,
        Jan = 1,
        Feb = 2,
        Mar = 3,
        Apr = 4,
        May = 5,
        Jun = 6,
        Jul = 7,
        Aug = 8,
        Sep = 9,
        Oct = 10,
        Nov = 11,
        Dec = 12,
    }
    impl Month {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MONTH_UNSPECIFIED",
                Self::Jan => "JAN",
                Self::Feb => "FEB",
                Self::Mar => "MAR",
                Self::Apr => "APR",
                Self::May => "MAY",
                Self::Jun => "JUN",
                Self::Jul => "JUL",
                Self::Aug => "AUG",
                Self::Sep => "SEP",
                Self::Oct => "OCT",
                Self::Nov => "NOV",
                Self::Dec => "DEC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MONTH_UNSPECIFIED" => Some(Self::Unspecified),
                "JAN" => Some(Self::Jan),
                "FEB" => Some(Self::Feb),
                "MAR" => Some(Self::Mar),
                "APR" => Some(Self::Apr),
                "MAY" => Some(Self::May),
                "JUN" => Some(Self::Jun),
                "JUL" => Some(Self::Jul),
                "AUG" => Some(Self::Aug),
                "SEP" => Some(Self::Sep),
                "OCT" => Some(Self::Oct),
                "NOV" => Some(Self::Nov),
                "DEC" => Some(Self::Dec),
                _ => None,
            }
        }
    }
}
/// 進行中的傳輸資訊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpTransfer {
    /// Type
    #[prost(enumeration = "ftp_types::FtpTransferType", tag = "1")]
    pub r#type: i32,
    /// File（檔名）
    #[prost(string, tag = "2")]
    pub file:   ::prost::alloc::string::String,
    /// Size (Bytes)
    #[prost(int64, tag = "3")]
    pub size:   i64,
    /// Speed (Bytes/s)
    #[prost(int64, tag = "4")]
    pub speed:  i64,
}
/// 單一 Session 條目
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpSession {
    /// 連線客戶端 IP
    #[prost(string, tag = "1")]
    pub ip:          ::prost::alloc::string::String,
    /// 已認證使用者
    #[prost(string, tag = "2")]
    pub username:    ::prost::alloc::string::String,
    /// 登入時間
    #[prost(message, optional, tag = "3")]
    pub login_time:  ::core::option::Option<FtpLoginTime>,
    /// 當前工作目錄
    #[prost(string, tag = "4")]
    pub current_dir: ::prost::alloc::string::String,
    /// 狀態
    #[prost(enumeration = "ftp_types::FtpSessionStatus", tag = "5")]
    pub status:      i32,
    /// 進行中的傳輸
    #[prost(message, optional, tag = "6")]
    pub transfer:    ::core::option::Option<FtpTransfer>,
}
/// Access_log 條目
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpAccessLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:       ::prost::alloc::string::String,
    /// Date（含 Week/Month/Day/Time{Hour,Min}）
    #[prost(message, optional, tag = "2")]
    pub date:     ::core::option::Option<super::common::Date>,
    /// 使用者
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// 行為
    #[prost(enumeration = "ftp_types::FtpAccessAction", tag = "4")]
    pub action:   i32,
    /// 檔名（若適用）
    #[prost(string, tag = "5")]
    pub file:     ::prost::alloc::string::String,
    /// 檔案大小（Bytes；若適用）
    #[prost(int64, tag = "6")]
    pub size:     i64,
    /// 成功/失敗
    #[prost(enumeration = "ftp_types::FtpAccessStatus", tag = "7")]
    pub status:   i32,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpLogs {
    /// Error_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub error_log:  ::prost::alloc::vec::Vec<super::common::ErrorLog>,
    /// Error_log.len
    #[prost(uint64, tag = "2")]
    pub errlength:  u64,
    /// Access_log\[\]
    #[prost(message, repeated, tag = "3")]
    pub access_log: ::prost::alloc::vec::Vec<FtpAccessLog>,
    /// Access_log.len
    #[prost(uint64, tag = "4")]
    pub acclength:  u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFtpResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 當前 FTP 活躍連線數
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// 目前 Session 列表
    #[prost(message, repeated, tag = "3")]
    pub sessions:    ::prost::alloc::vec::Vec<FtpSession>,
    /// 日誌
    #[prost(message, optional, tag = "4")]
    pub logs:        ::core::option::Option<FtpLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FtpActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ftp/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartFtpRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<FtpActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartFtpResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ftp/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopFtpRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<FtpActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopFtpResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/ftp/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartFtpRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<FtpActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartFtpResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// 伺服器狀態監控  GET /api/server/samba
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSambaRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Share 狀態
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SambaTypes {}
/// Nested message and enum types in `SambaTypes`.
pub mod samba_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ShareStatus {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
    }
    impl ShareStatus {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHARE_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHARE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SambaLogLevel {
        Unspecified = 0,
        Info = 1,
        Warn = 2,
        Error = 3,
    }
    impl SambaLogLevel {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SAMBA_LOG_LEVEL_UNSPECIFIED",
                Self::Info => "INFO",
                Self::Warn => "WARN",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SAMBA_LOG_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO" => Some(Self::Info),
                "WARN" => Some(Self::Warn),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// 單一 Share 條目
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SambaShare {
    /// Name
    #[prost(string, tag = "1")]
    pub name:        ::prost::alloc::string::String,
    /// Path
    #[prost(string, tag = "2")]
    pub path:        ::prost::alloc::string::String,
    /// Users（目前訪問人數）
    #[prost(int64, tag = "3")]
    pub users:       i64,
    /// Permissions（如 "read", "write"...）
    #[prost(string, tag = "4")]
    pub permissions: ::prost::alloc::string::String,
    /// Status
    #[prost(enumeration = "samba_types::ShareStatus", tag = "5")]
    pub status:      i32,
}
/// Samba 單筆日誌
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SambaLog {
    /// Date
    #[prost(message, optional, tag = "1")]
    pub date:    ::core::option::Option<super::common::Date>,
    /// 客戶端 IP:Port
    #[prost(string, tag = "2")]
    pub client:  ::prost::alloc::string::String,
    /// 事件描述
    #[prost(string, tag = "3")]
    pub event:   ::prost::alloc::string::String,
    /// 記錄等級
    #[prost(enumeration = "samba_types::SambaLogLevel", tag = "4")]
    pub level:   i32,
    /// 訊息
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
}
/// Logs 區塊
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SambaLogs {
    /// Samba_log\[\]
    #[prost(message, repeated, tag = "1")]
    pub samba_log:        ::prost::alloc::vec::Vec<SambaLog>,
    /// Samba_log_Length
    #[prost(uint64, tag = "2")]
    pub samba_log_length: u64,
}
/// 狀態回應（flatten 共用資訊）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSambaResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common_info: ::core::option::Option<super::common::CommonInfo>,
    /// 當前連線到 Samba 的客戶端數量
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// Shares\[\]
    #[prost(message, repeated, tag = "3")]
    pub shares:      ::prost::alloc::vec::Vec<SambaShare>,
    /// Logs
    #[prost(message, optional, tag = "4")]
    pub logs:        ::core::option::Option<SambaLogs>,
}
/// 動作請求
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SambaActionRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// 動作回應（統一使用 common.ActionResult: {type, message}）
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SambaActionResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/samba/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSambaRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<SambaActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSambaResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/samba/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSambaRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<SambaActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSambaResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// /api/server/samba/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSambaRequest {
    #[prost(message, optional, tag = "1")]
    pub inner: ::core::option::Option<SambaActionRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSambaResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// GET /api/server/installed
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerInstalledPcsRequest {
    /// Server name, e.g., "apache", "nginx"
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerInstalledPcsResponse {
    /// key = uuid, value = { Hostname, Status(active|stopped), Cpu, Memory }
    #[prost(map = "string, message", tag = "1")]
    pub pcs: ::std::collections::HashMap<::prost::alloc::string::String, super::common::CommonInfo>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// GET /api/server/noinstall
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerNotInstalledPcsRequest {
    /// Server name
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServerNotInstalledPcsResponse {
    /// key = uuid
    #[prost(map = "string, message", tag = "1")]
    pub pcs: ::std::collections::HashMap<::prost::alloc::string::String, super::common::CommonInfo>,
    /// pcs.len
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
/// POST /api/server/install
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallServerRequest {
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
    /// target machines
    #[prost(string, repeated, tag = "2")]
    pub uuids:  ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstallServerResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// GET /api/server/squid
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSquidRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SquidAccessLog {
    /// Ip
    #[prost(string, tag = "1")]
    pub ip:           ::prost::alloc::string::String,
    /// Date {Year, Week, Month, Day, Time{Hour, Min}}
    #[prost(message, optional, tag = "2")]
    pub date:         ::core::option::Option<super::common::Date>,
    /// Method
    #[prost(string, tag = "3")]
    pub method:       ::prost::alloc::string::String,
    /// URL
    #[prost(string, tag = "4")]
    pub url:          ::prost::alloc::string::String,
    /// Status
    #[prost(int64, tag = "5")]
    pub status:       i64,
    /// Bytes_Served
    #[prost(int64, tag = "6")]
    pub bytes_served: i64,
    /// Referer
    #[prost(string, tag = "7")]
    pub referer:      ::prost::alloc::string::String,
    /// User_Agent
    #[prost(string, tag = "8")]
    pub user_agent:   ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SquidLogs {
    /// Access_log
    #[prost(message, repeated, tag = "1")]
    pub access_log:        ::prost::alloc::vec::Vec<SquidAccessLog>,
    /// Access_log_Length
    #[prost(uint64, tag = "2")]
    pub access_log_length: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSquidResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common:             ::core::option::Option<super::common::CommonInfo>,
    /// 當前活躍代理連線數
    #[prost(int64, tag = "2")]
    pub connections:        i64,
    /// 緩存命中數
    #[prost(int64, tag = "3")]
    pub cache_hits:         i64,
    /// 緩存未命中數
    #[prost(int64, tag = "4")]
    pub cache_misses:       i64,
    /// 總請求數量
    #[prost(int64, tag = "5")]
    pub requests_processed: i64,
    /// 存取日誌
    #[prost(message, optional, tag = "6")]
    pub logs:               ::core::option::Option<SquidLogs>,
}
/// POST /api/server/squid/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSquidRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSquidResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/server/squid/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSquidRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSquidResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/server/squid/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSquidRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSquidResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// GET /api/server/ssh
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSshRequest {
    /// 目標主機
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
/// Last_Login
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LastLogin {
    /// User
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    /// Date
    #[prost(message, optional, tag = "2")]
    pub date: ::core::option::Option<super::common::Date>,
    /// Ip
    #[prost(string, tag = "3")]
    pub ip:   ::prost::alloc::string::String,
}
/// Auth log enums
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SshTypes {}
/// Nested message and enum types in `SshTypes`.
pub mod ssh_types {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SshAction {
        Unspecified = 0,
        Login = 1,
        Logout = 2,
        FailedLogin = 3,
    }
    impl SshAction {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSH_ACTION_UNSPECIFIED",
                Self::Login => "LOGIN",
                Self::Logout => "LOGOUT",
                Self::FailedLogin => "FAILED_LOGIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSH_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "LOGIN" => Some(Self::Login),
                "LOGOUT" => Some(Self::Logout),
                "FAILED_LOGIN" => Some(Self::FailedLogin),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum SshResult {
        Unspecified = 0,
        Success = 1,
        Failure = 2,
    }
    impl SshResult {
        /// String value of the enum field names used in the ProtoBuf
        /// definition.
        ///
        /// The values are not transformed in any way and thus are considered
        /// stable (if the ProtoBuf definition does not change) and safe
        /// for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSH_RESULT_UNSPECIFIED",
                Self::Success => "SUCCESS",
                Self::Failure => "FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSH_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCESS" => Some(Self::Success),
                "FAILURE" => Some(Self::Failure),
                _ => None,
            }
        }
    }
}
/// 單筆 Auth 日誌
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshAuthLog {
    /// Date
    #[prost(message, optional, tag = "1")]
    pub date:    ::core::option::Option<super::common::Date>,
    /// User
    #[prost(string, tag = "2")]
    pub user:    ::prost::alloc::string::String,
    /// Action
    #[prost(enumeration = "ssh_types::SshAction", tag = "3")]
    pub action:  i32,
    /// Result
    #[prost(enumeration = "ssh_types::SshResult", tag = "4")]
    pub result:  i32,
    /// Ip
    #[prost(string, tag = "5")]
    pub ip:      ::prost::alloc::string::String,
    /// Message
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
}
/// Auth 日誌集合
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SshLogs {
    /// Auth_log
    #[prost(message, repeated, tag = "1")]
    pub auth_log:        ::prost::alloc::vec::Vec<SshAuthLog>,
    /// Auth_log_Length
    #[prost(uint64, tag = "2")]
    pub auth_log_length: u64,
}
/// 伺服器狀態監控回應
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSshResponse {
    /// {Hostname, Status(active|stopped), Cpu, Memory}
    #[prost(message, optional, tag = "1")]
    pub common:      ::core::option::Option<super::common::CommonInfo>,
    /// 當前活躍的 SSH 連線數
    #[prost(int64, tag = "2")]
    pub connections: i64,
    /// 最後登入資訊
    #[prost(message, optional, tag = "3")]
    pub last_login:  ::core::option::Option<LastLogin>,
    /// 認證日誌
    #[prost(message, optional, tag = "4")]
    pub logs:        ::core::option::Option<SshLogs>,
}
/// POST /api/server/ssh/action/start
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSshRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartSshResponse {
    /// {Type, Message}
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/server/ssh/action/stop
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSshRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSshResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
/// POST /api/server/ssh/action/restart
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSshRequest {
    #[prost(string, tag = "1")]
    pub uuid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartSshResponse {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<super::common::ActionResult>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Zone {
    Unspecified = 0,
    Info = 1,
    Cluster = 2,
}
impl Zone {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ZONE_UNSPECIFIED",
            Self::Info => "INFO",
            Self::Cluster => "CLUSTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ZONE_UNSPECIFIED" => Some(Self::Unspecified),
            "INFO" => Some(Self::Info),
            "CLUSTER" => Some(Self::Cluster),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Target {
    Unspecified = 0,
    Safe = 1,
    Warn = 2,
    Dang = 3,
    Cpu = 4,
    Memory = 5,
    Disk = 6,
}
impl Target {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TARGET_UNSPECIFIED",
            Self::Safe => "SAFE",
            Self::Warn => "WARN",
            Self::Dang => "DANG",
            Self::Cpu => "CPU",
            Self::Memory => "MEMORY",
            Self::Disk => "DISK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_UNSPECIFIED" => Some(Self::Unspecified),
            "SAFE" => Some(Self::Safe),
            "WARN" => Some(Self::Warn),
            "DANG" => Some(Self::Dang),
            "CPU" => Some(Self::Cpu),
            "MEMORY" => Some(Self::Memory),
            "DISK" => Some(Self::Disk),
            _ => None,
        }
    }
}
/// ========== Backup 專用型別 ==========
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupLocation {
    Unspecified = 0,
    Remote = 1,
    Local = 2,
}
impl BackupLocation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BACKUP_LOCATION_UNSPECIFIED",
            Self::Remote => "REMOTE",
            Self::Local => "LOCAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_LOCATION_UNSPECIFIED" => Some(Self::Unspecified),
            "REMOTE" => Some(Self::Remote),
            "LOCAL" => Some(Self::Local),
            _ => None,
        }
    }
}
/// 顏色：可為預設色或自訂字串（例如 Hex）
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PredefinedColor {
    Unspecified = 0,
    Red = 1,
    Green = 2,
    Blue = 3,
    Yellow = 4,
    Purple = 5,
    Orange = 6,
    Black = 7,
    White = 8,
    Gray = 9,
}
impl PredefinedColor {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PREDEFINED_COLOR_UNSPECIFIED",
            Self::Red => "RED",
            Self::Green => "GREEN",
            Self::Blue => "BLUE",
            Self::Yellow => "YELLOW",
            Self::Purple => "PURPLE",
            Self::Orange => "ORANGE",
            Self::Black => "BLACK",
            Self::White => "WHITE",
            Self::Gray => "GRAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PREDEFINED_COLOR_UNSPECIFIED" => Some(Self::Unspecified),
            "RED" => Some(Self::Red),
            "GREEN" => Some(Self::Green),
            "BLUE" => Some(Self::Blue),
            "YELLOW" => Some(Self::Yellow),
            "PURPLE" => Some(Self::Purple),
            "ORANGE" => Some(Self::Orange),
            "BLACK" => Some(Self::Black),
            "WHITE" => Some(Self::White),
            "GRAY" => Some(Self::Gray),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoadStatus {
    Unspecified = 0,
    /// 已加載
    Load = 1,
    /// 未加載
    Notload = 2,
}
impl LoadStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LOAD_STATUS_UNSPECIFIED",
            Self::Load => "LOAD",
            Self::Notload => "NOTLOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOAD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "LOAD" => Some(Self::Load),
            "NOTLOAD" => Some(Self::Notload),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnableStatus {
    Unspecified = 0,
    Enable = 1,
    Disable = 2,
}
impl EnableStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENABLE_STATUS_UNSPECIFIED",
            Self::Enable => "ENABLE",
            Self::Disable => "DISABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENABLE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ENABLE" => Some(Self::Enable),
            "DISABLE" => Some(Self::Disable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileUnit {
    Unspecified = 0,
    B = 1,
    Kb = 2,
    Mb = 3,
    Gb = 4,
}
impl FileUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FILE_UNIT_UNSPECIFIED",
            Self::B => "B",
            Self::Kb => "KB",
            Self::Mb => "MB",
            Self::Gb => "GB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILE_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "B" => Some(Self::B),
            "KB" => Some(Self::Kb),
            "MB" => Some(Self::Mb),
            "GB" => Some(Self::Gb),
            _ => None,
        }
    }
}
/// 共同列舉
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FirewallStatus {
    Unspecified = 0,
    Active = 1,
    Inactive = 2,
}
impl FirewallStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FIREWALL_STATUS_UNSPECIFIED",
            Self::Active => "ACTIVE",
            Self::Inactive => "INACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIREWALL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTIVE" => Some(Self::Active),
            "INACTIVE" => Some(Self::Inactive),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChainKind {
    Unspecified = 0,
    Input = 1,
    Forward = 2,
    Output = 3,
}
impl ChainKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHAIN_KIND_UNSPECIFIED",
            Self::Input => "INPUT",
            Self::Forward => "FORWARD",
            Self::Output => "OUTPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHAIN_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "INPUT" => Some(Self::Input),
            "FORWARD" => Some(Self::Forward),
            "OUTPUT" => Some(Self::Output),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Verdict {
    Unspecified = 0,
    Accept = 1,
    Drop = 2,
    Reject = 3,
}
impl Verdict {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VERDICT_UNSPECIFIED",
            Self::Accept => "ACCEPT",
            Self::Drop => "DROP",
            Self::Reject => "REJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VERDICT_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCEPT" => Some(Self::Accept),
            "DROP" => Some(Self::Drop),
            "REJECT" => Some(Self::Reject),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NicType {
    Unspecified = 0,
    Virtual = 1,
    Physical = 2,
}
impl NicType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NIC_TYPE_UNSPECIFIED",
            Self::Virtual => "VIRTUAL",
            Self::Physical => "PHYSICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NIC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "VIRTUAL" => Some(Self::Virtual),
            "PHYSICAL" => Some(Self::Physical),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NicStatus {
    Unspecified = 0,
    Up = 1,
    Down = 2,
}
impl NicStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NIC_STATUS_UNSPECIFIED",
            Self::Up => "UP",
            Self::Down => "DOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NIC_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "UP" => Some(Self::Up),
            "DOWN" => Some(Self::Down),
            _ => None,
        }
    }
}
/// PATCH /api/network/route （單欄更新）
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RouteField {
    Unspecified = 0,
    Via = 1,
    Dev = 2,
    Proto = 3,
    Metric = 4,
    Scope = 5,
    Src = 6,
}
impl RouteField {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROUTE_FIELD_UNSPECIFIED",
            Self::Via => "VIA",
            Self::Dev => "DEV",
            Self::Proto => "PROTO",
            Self::Metric => "METRIC",
            Self::Scope => "SCOPE",
            Self::Src => "SRC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUTE_FIELD_UNSPECIFIED" => Some(Self::Unspecified),
            "VIA" => Some(Self::Via),
            "DEV" => Some(Self::Dev),
            "PROTO" => Some(Self::Proto),
            "METRIC" => Some(Self::Metric),
            "SCOPE" => Some(Self::Scope),
            "SRC" => Some(Self::Src),
            _ => None,
        }
    }
}
/// 單一套件狀態
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PackageStatus {
    Unspecified = 0,
    /// Installed
    Installed = 1,
    /// Notinstall
    Notinstall = 2,
}
impl PackageStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PACKAGE_STATUS_UNSPECIFIED",
            Self::Installed => "INSTALLED",
            Self::Notinstall => "NOTINSTALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PACKAGE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTALLED" => Some(Self::Installed),
            "NOTINSTALL" => Some(Self::Notinstall),
            _ => None,
        }
    }
}
/// 查詢日誌枚舉
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DnsQueryType {
    Unspecified = 0,
    A = 1,
    Aaaa = 2,
    Cname = 3,
    Mx = 4,
    Ns = 5,
    Ptr = 6,
    Soa = 7,
    Txt = 8,
    Srv = 9,
    Dnskey = 10,
}
impl DnsQueryType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DNS_QUERY_TYPE_UNSPECIFIED",
            Self::A => "A",
            Self::Aaaa => "AAAA",
            Self::Cname => "CNAME",
            Self::Mx => "MX",
            Self::Ns => "NS",
            Self::Ptr => "PTR",
            Self::Soa => "SOA",
            Self::Txt => "TXT",
            Self::Srv => "SRV",
            Self::Dnskey => "DNSKEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DNS_QUERY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "A" => Some(Self::A),
            "AAAA" => Some(Self::Aaaa),
            "CNAME" => Some(Self::Cname),
            "MX" => Some(Self::Mx),
            "NS" => Some(Self::Ns),
            "PTR" => Some(Self::Ptr),
            "SOA" => Some(Self::Soa),
            "TXT" => Some(Self::Txt),
            "SRV" => Some(Self::Srv),
            "DNSKEY" => Some(Self::Dnskey),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DnsQueryStatus {
    Unspecified = 0,
    Noerror = 1,
    Nxdomain = 2,
    Servfail = 3,
    Refused = 4,
}
impl DnsQueryStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DNS_QUERY_STATUS_UNSPECIFIED",
            Self::Noerror => "NOERROR",
            Self::Nxdomain => "NXDOMAIN",
            Self::Servfail => "SERVFAIL",
            Self::Refused => "REFUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DNS_QUERY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "NOERROR" => Some(Self::Noerror),
            "NXDOMAIN" => Some(Self::Nxdomain),
            "SERVFAIL" => Some(Self::Servfail),
            "REFUSED" => Some(Self::Refused),
            _ => None,
        }
    }
}
/// Access_log 枚舉
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LdapMethod {
    Unspecified = 0,
    Bind = 1,
    Search = 2,
    Add = 3,
    Delete = 4,
    Modify = 5,
    Moddn = 6,
    Compare = 7,
    Unbind = 8,
    Extended = 9,
}
impl LdapMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LDAP_METHOD_UNSPECIFIED",
            Self::Bind => "BIND",
            Self::Search => "SEARCH",
            Self::Add => "ADD",
            Self::Delete => "DELETE",
            Self::Modify => "MODIFY",
            Self::Moddn => "MODDN",
            Self::Compare => "COMPARE",
            Self::Unbind => "UNBIND",
            Self::Extended => "EXTENDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LDAP_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "BIND" => Some(Self::Bind),
            "SEARCH" => Some(Self::Search),
            "ADD" => Some(Self::Add),
            "DELETE" => Some(Self::Delete),
            "MODIFY" => Some(Self::Modify),
            "MODDN" => Some(Self::Moddn),
            "COMPARE" => Some(Self::Compare),
            "UNBIND" => Some(Self::Unbind),
            "EXTENDED" => Some(Self::Extended),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LdapProtocol {
    Unspecified = 0,
    LdaPv2 = 1,
    LdaPv3 = 2,
}
impl LdapProtocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LDAP_PROTOCOL_UNSPECIFIED",
            Self::LdaPv2 => "LDAPv2",
            Self::LdaPv3 => "LDAPv3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LDAP_PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "LDAPv2" => Some(Self::LdaPv2),
            "LDAPv3" => Some(Self::LdaPv3),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LdapOpStatus {
    Unspecified = 0,
    Success = 1,
    Authfailed = 2,
    Notfound = 3,
    Error = 4,
}
impl LdapOpStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic
    /// use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LDAP_OP_STATUS_UNSPECIFIED",
            Self::Success => "SUCCESS",
            Self::Authfailed => "AUTHFAILED",
            Self::Notfound => "NOTFOUND",
            Self::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LDAP_OP_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SUCCESS" => Some(Self::Success),
            "AUTHFAILED" => Some(Self::Authfailed),
            "NOTFOUND" => Some(Self::Notfound),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
/// Generated client implementations.
#[cfg(feature = "restful-client")]
pub mod restful_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::{http::Uri, *};
    /// ========== Service ==========
    #[derive(Debug, Clone)]
    pub struct RestfulServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RestfulServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RestfulServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RestfulServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RestfulServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond
        /// with an error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Login
        pub async fn login(
            &mut self,
            request: impl tonic::IntoRequest<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/Login");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "Login"));
            self.inner.unary(req, path, codec).await
        }
        /// Dashboard
        pub async fn get_all_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllInfoResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllInfo");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConfigResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Backup
        pub async fn backup_now(
            &mut self,
            request: impl tonic::IntoRequest<super::BackupNowRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupNowResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/BackupNow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "BackupNow"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBackupsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetBackups");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetBackups"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reduce_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::ReductionRequest>,
        ) -> std::result::Result<tonic::Response<super::ReductionResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/ReduceBackup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "ReduceBackup"));
            self.inner.unary(req, path, codec).await
        }
        /// Mca
        pub async fn get_valid_certs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetValidCertsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetValidCertsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetValidCerts");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetValidCerts"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_revoked_certs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRevokedCertsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRevokedCertsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetRevokedCerts");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetRevokedCerts"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn revoke_cert(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeCertRequest>,
        ) -> std::result::Result<tonic::Response<super::RevokeCertResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RevokeCert");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RevokeCert"));
            self.inner.unary(req, path, codec).await
        }
        /// PC
        pub async fn add_pc(
            &mut self,
            request: impl tonic::IntoRequest<super::AddPcRequest>,
        ) -> std::result::Result<tonic::Response<super::AddPcResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/AddPc");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "AddPc"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_all_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllPcsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllPcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_specific_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSpecificPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSpecificPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSpecificPcs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetSpecificPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePcsRequest>,
        ) -> std::result::Result<tonic::Response<super::DeletePcsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeletePcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeletePcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn reboot_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::RebootPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::RebootPcsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RebootPcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RebootPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn shutdown_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::ShutdownPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::ShutdownPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/ShutdownPcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "ShutdownPcs"));
            self.inner.unary(req, path, codec).await
        }
        /// PC Group
        pub async fn get_pc_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPcGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcGroupsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetPcGroups");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetPcGroups"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_pc_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::CreatePcGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/CreatePcGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreatePcGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_pc_group(
            &mut self,
            request: impl tonic::IntoRequest<super::PutPcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::PutPcGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutPcGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutPcGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_pc_group(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchPcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchPcGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchPcGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchPcGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_pc_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::DeletePcGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DeletePcGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeletePcGroup"));
            self.inner.unary(req, path, codec).await
        }
        /// Role
        pub async fn get_roles(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRolesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRolesResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetRoles");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetRoles"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_role_users(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoleUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoleUsersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetRoleUsers");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetRoleUsers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_role(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateRoleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateRole");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateRole"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_role(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteRoleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteRole");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteRole"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_role_members(
            &mut self,
            request: impl tonic::IntoRequest<super::PutRoleMembersRequest>,
        ) -> std::result::Result<tonic::Response<super::PutRoleMembersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PutRoleMembers");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "PutRoleMembers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_role(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchRoleResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchRole");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchRole"));
            self.inner.unary(req, path, codec).await
        }
        /// Module
        pub async fn get_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetModules");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetModules"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/UploadModules");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "UploadModules"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/UpdateModules");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "UpdateModules"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_module_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchModuleSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchModuleSettingsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchModuleSettings");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "PatchModuleSettings"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteModules");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteModules"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn enable_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::EnableModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/EnableModules");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "EnableModules"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disable_modules(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::DisableModulesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DisableModules");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DisableModules"));
            self.inner.unary(req, path, codec).await
        }
        /// IP Access Control
        pub async fn get_ip_access(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIpAccessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetIpAccessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetIpAccess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetIpAccess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn post_ip(
            &mut self,
            request: impl tonic::IntoRequest<super::PostIpRequest>,
        ) -> std::result::Result<tonic::Response<super::PostIpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PostIp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PostIp"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_ip(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIpRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteIp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteIp"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_ip_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::PutIpModeRequest>,
        ) -> std::result::Result<tonic::Response<super::PutIpModeResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutIpMode");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutIpMode"));
            self.inner.unary(req, path, codec).await
        }
        /// Setting Values
        pub async fn get_setting_values(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSettingValuesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSettingValuesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSettingValues");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetSettingValues"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_setting_values(
            &mut self,
            request: impl tonic::IntoRequest<super::PutSettingValuesRequest>,
        ) -> std::result::Result<tonic::Response<super::PutSettingValuesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PutSettingValues");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "PutSettingValues"));
            self.inner.unary(req, path, codec).await
        }
        /// Users
        pub async fn get_users(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::GetUsersResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetUsers");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetUsers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_user(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateUserResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateUser");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateUser"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_users(
            &mut self,
            request: impl tonic::IntoRequest<super::PutUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::PutUsersResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutUsers");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutUsers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_users(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchUsersResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchUsers");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchUsers"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_user(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUserRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteUserResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteUser");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteUser"));
            self.inner.unary(req, path, codec).await
        }
        /// Groups
        pub async fn get_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGroupsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetGroups");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetGroups"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateGroup"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::PutGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::PutGroupsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutGroups");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutGroups"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchGroupsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchGroups");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchGroups"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteGroupResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteGroup");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteGroup"));
            self.inner.unary(req, path, codec).await
        }
        /// Cron
        pub async fn get_cron_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCronJobsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCronJobsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetCronJobs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetCronJobs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_cron(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCronRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateCronResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateCron");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateCron"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_cron(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCronRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteCronResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteCron");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteCron"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_cron(
            &mut self,
            request: impl tonic::IntoRequest<super::PutCronRequest>,
        ) -> std::result::Result<tonic::Response<super::PutCronResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutCron");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutCron"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn import_cron(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCronRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportCronResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/ImportCron");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "ImportCron"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn export_cron(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportCronRequest>,
        ) -> std::result::Result<tonic::Response<super::ExportCronResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/ExportCron");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "ExportCron"));
            self.inner.unary(req, path, codec).await
        }
        /// pdir
        pub async fn get_pdir_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPdirPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPdirPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetPdirPcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetPdirPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_pdir_one(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPdirOneRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPdirOneResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetPdirOne");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetPdirOne"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload_pdir_files(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadPdirFilesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadPdirFilesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/UploadPdirFiles");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "UploadPdirFiles"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn download_pdir_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DownloadPdirFileRequest>,
        ) -> std::result::Result<tonic::Response<super::DownloadPdirFileResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DownloadPdirFile");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DownloadPdirFile"));
            self.inner.unary(req, path, codec).await
        }
        /// vdir
        pub async fn get_vdir_path(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVdirPathRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVdirPathResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetVdirPath");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetVdirPath"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn upload_vdir_files(
            &mut self,
            request: impl tonic::IntoRequest<super::UploadVdirFilesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadVdirFilesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/UploadVdirFiles");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "UploadVdirFiles"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn download_vdir_file(
            &mut self,
            request: impl tonic::IntoRequest<super::DownloadVdirFileRequest>,
        ) -> std::result::Result<tonic::Response<super::DownloadVdirFileResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DownloadVdirFile");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DownloadVdirFile"));
            self.inner.unary(req, path, codec).await
        }
        /// System logs
        pub async fn get_sys_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSysLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSysLogsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSysLogs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetSysLogs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_sys_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySysLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::QuerySysLogsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/QuerySysLogs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "QuerySysLogs"));
            self.inner.unary(req, path, codec).await
        }
        /// PC logs
        pub async fn get_pc_log_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPcLogPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcLogPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetPcLogPcs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetPcLogPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_pc_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPcLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcLogsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetPcLogs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetPcLogs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn query_pc_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPcLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPcLogsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/QueryPcLogs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "QueryPcLogs"));
            self.inner.unary(req, path, codec).await
        }
        /// Firewall
        pub async fn get_firewall_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFirewallPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetFirewallPcs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetFirewallPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_firewall(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFirewallResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetFirewall");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetFirewall"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn add_firewall_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::AddFirewallRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::AddFirewallRuleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/AddFirewallRule");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "AddFirewallRule"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_firewall_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteFirewallRuleResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteFirewallRule");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DeleteFirewallRule"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_firewall_status(
            &mut self,
            request: impl tonic::IntoRequest<super::PutFirewallStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::PutFirewallStatusResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PutFirewallStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "PutFirewallStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_firewall_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::PutFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::PutFirewallPolicyResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PutFirewallPolicy");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "PutFirewallPolicy"));
            self.inner.unary(req, path, codec).await
        }
        /// Network Interface
        pub async fn get_all_net(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllNetRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllNetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllNet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllNet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_net(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNetRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateNetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateNet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateNet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_net(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteNetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteNet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteNet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_net(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchNetRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchNetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchNet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchNet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_net(
            &mut self,
            request: impl tonic::IntoRequest<super::PutNetRequest>,
        ) -> std::result::Result<tonic::Response<super::PutNetResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutNet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutNet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn net_up(
            &mut self,
            request: impl tonic::IntoRequest<super::NetUpRequest>,
        ) -> std::result::Result<tonic::Response<super::NetUpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/NetUp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "NetUp"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn net_down(
            &mut self,
            request: impl tonic::IntoRequest<super::NetDownRequest>,
        ) -> std::result::Result<tonic::Response<super::NetDownResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/NetDown");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "NetDown"));
            self.inner.unary(req, path, codec).await
        }
        /// Routing
        pub async fn get_all_route(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllRouteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllRoute");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllRoute"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_route(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateRouteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/CreateRoute");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "CreateRoute"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_route(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteRouteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteRoute");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "DeleteRoute"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_route(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchRouteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchRoute");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchRoute"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_route(
            &mut self,
            request: impl tonic::IntoRequest<super::PutRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::PutRouteResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutRoute");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutRoute"));
            self.inner.unary(req, path, codec).await
        }
        /// DNS / Hostname
        pub async fn get_all_dns(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllDnsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllDnsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllDns");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllDns"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn patch_hostname(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchHostnameRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchHostnameResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/PatchHostname");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PatchHostname"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn put_dns(
            &mut self,
            request: impl tonic::IntoRequest<super::PutDnsRequest>,
        ) -> std::result::Result<tonic::Response<super::PutDnsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/PutDns");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "PutDns"));
            self.inner.unary(req, path, codec).await
        }
        /// Process
        pub async fn get_all_process(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetAllProcess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetAllProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_one_process(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOneProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetOneProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetOneProcess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetOneProcess"));
            self.inner.unary(req, path, codec).await
        }
        /// Process
        pub async fn start_process(
            &mut self,
            request: impl tonic::IntoRequest<super::StartProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StartProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartProcess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_process(
            &mut self,
            request: impl tonic::IntoRequest<super::StopProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StopProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopProcess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_process(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartProcess");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "RestartProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn enable_process(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::EnableProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/EnableProcess");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "EnableProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn disable_process(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::DisableProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DisableProcess");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DisableProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_enable_process(
            &mut self,
            request: impl tonic::IntoRequest<super::StartEnableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StartEnableProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/StartEnableProcess");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "StartEnableProcess"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_disable_process(
            &mut self,
            request: impl tonic::IntoRequest<super::StopDisableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StopDisableProcessResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/StopDisableProcess");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "StopDisableProcess"));
            self.inner.unary(req, path, codec).await
        }
        /// Software Inventory
        pub async fn get_software(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSoftwareResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSoftware");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetSoftware"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn install_software(
            &mut self,
            request: impl tonic::IntoRequest<super::InstallSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::PackageActionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/InstallSoftware");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "InstallSoftware"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_software(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::PackageActionResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/DeleteSoftware");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "DeleteSoftware"));
            self.inner.unary(req, path, codec).await
        }
        /// Apache Webserver
        pub async fn get_apache_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::GetApacheResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetApacheStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetApacheStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_apache(
            &mut self,
            request: impl tonic::IntoRequest<super::StartApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::StartApacheResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartApache");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartApache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_apache(
            &mut self,
            request: impl tonic::IntoRequest<super::StopApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::StopApacheResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopApache");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopApache"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_apache(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartApacheResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartApache");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartApache"));
            self.inner.unary(req, path, codec).await
        }
        /// BIND DNS Server
        pub async fn get_bind_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBindRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBindResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetBindStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetBindStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_bind(
            &mut self,
            request: impl tonic::IntoRequest<super::StartBindRequest>,
        ) -> std::result::Result<tonic::Response<super::StartBindResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartBind");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartBind"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_bind(
            &mut self,
            request: impl tonic::IntoRequest<super::StopBindRequest>,
        ) -> std::result::Result<tonic::Response<super::StopBindResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopBind");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopBind"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_bind(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartBindRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartBindResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartBind");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartBind"));
            self.inner.unary(req, path, codec).await
        }
        /// LDAP Server
        pub async fn get_ldap_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLdapResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetLdapStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetLdapStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_ldap(
            &mut self,
            request: impl tonic::IntoRequest<super::StartLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::StartLdapResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartLdap");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartLdap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_ldap(
            &mut self,
            request: impl tonic::IntoRequest<super::StopLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::StopLdapResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopLdap");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopLdap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_ldap(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartLdapResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartLdap");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartLdap"));
            self.inner.unary(req, path, codec).await
        }
        /// MySQL Server
        pub async fn get_my_sql_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMySqlResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetMySqlStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetMySqlStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_my_sql(
            &mut self,
            request: impl tonic::IntoRequest<super::StartMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::StartMySqlResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartMySql");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartMySql"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_my_sql(
            &mut self,
            request: impl tonic::IntoRequest<super::StopMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::StopMySqlResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopMySql");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopMySql"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_my_sql(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartMySqlResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartMySql");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartMySql"));
            self.inner.unary(req, path, codec).await
        }
        /// Nginx Server
        pub async fn get_nginx_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNginxResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetNginxStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetNginxStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_nginx(
            &mut self,
            request: impl tonic::IntoRequest<super::StartNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::StartNginxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartNginx");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartNginx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_nginx(
            &mut self,
            request: impl tonic::IntoRequest<super::StopNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::StopNginxResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopNginx");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopNginx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_nginx(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartNginxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartNginx");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartNginx"));
            self.inner.unary(req, path, codec).await
        }
        /// FTP Server
        pub async fn get_ftp_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFtpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetFtpStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetFtpStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_ftp(
            &mut self,
            request: impl tonic::IntoRequest<super::StartFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::StartFtpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartFtp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartFtp"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_ftp(
            &mut self,
            request: impl tonic::IntoRequest<super::StopFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::StopFtpResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopFtp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopFtp"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_ftp(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartFtpResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartFtp");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartFtp"));
            self.inner.unary(req, path, codec).await
        }
        /// Samba Server
        pub async fn get_samba_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSambaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSambaStatus");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetSambaStatus"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_samba(
            &mut self,
            request: impl tonic::IntoRequest<super::StartSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSambaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartSamba");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartSamba"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_samba(
            &mut self,
            request: impl tonic::IntoRequest<super::StopSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSambaResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopSamba");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopSamba"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_samba(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSambaResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartSamba");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartSamba"));
            self.inner.unary(req, path, codec).await
        }
        /// Server Installed/Not Installed Lists & Install
        pub async fn get_server_installed_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServerInstalledPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetServerInstalledPcsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/restful.RestfulService/GetServerInstalledPcs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetServerInstalledPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_server_not_installed_pcs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServerNotInstalledPcsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServerNotInstalledPcsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/restful.RestfulService/GetServerNotInstalledPcs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("restful.RestfulService", "GetServerNotInstalledPcs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn install_server(
            &mut self,
            request: impl tonic::IntoRequest<super::InstallServerRequest>,
        ) -> std::result::Result<tonic::Response<super::InstallServerResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/restful.RestfulService/InstallServer");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "InstallServer"));
            self.inner.unary(req, path, codec).await
        }
        /// Squid
        pub async fn get_squid(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSquidResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSquid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetSquid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_squid(
            &mut self,
            request: impl tonic::IntoRequest<super::StartSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSquidResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartSquid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartSquid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_squid(
            &mut self,
            request: impl tonic::IntoRequest<super::StopSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSquidResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopSquid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopSquid"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_squid(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSquidResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartSquid");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartSquid"));
            self.inner.unary(req, path, codec).await
        }
        /// SSH
        pub async fn get_ssh(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSshRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSshResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/GetSsh");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "GetSsh"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn start_ssh(
            &mut self,
            request: impl tonic::IntoRequest<super::StartSshRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSshResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StartSsh");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StartSsh"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stop_ssh(
            &mut self,
            request: impl tonic::IntoRequest<super::StopSshRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSshResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/StopSsh");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "StopSsh"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restart_ssh(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartSshRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSshResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/restful.RestfulService/RestartSsh");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("restful.RestfulService", "RestartSsh"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "restful-server")]
pub mod restful_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for
    /// use with RestfulServiceServer.
    #[async_trait]
    pub trait RestfulService: std::marker::Send + std::marker::Sync + 'static {
        /// Login
        async fn login(
            &self,
            request: tonic::Request<super::LoginRequest>,
        ) -> std::result::Result<tonic::Response<super::LoginResponse>, tonic::Status>;
        /// Dashboard
        async fn get_all_info(
            &self,
            request: tonic::Request<super::GetAllInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllInfoResponse>, tonic::Status>;
        async fn get_info(
            &self,
            request: tonic::Request<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status>;
        async fn get_config(
            &self,
            request: tonic::Request<super::GetConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConfigResponse>, tonic::Status>;
        /// Backup
        async fn backup_now(
            &self,
            request: tonic::Request<super::BackupNowRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupNowResponse>, tonic::Status>;
        async fn get_backups(
            &self,
            request: tonic::Request<super::GetBackupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBackupsResponse>, tonic::Status>;
        async fn reduce_backup(
            &self,
            request: tonic::Request<super::ReductionRequest>,
        ) -> std::result::Result<tonic::Response<super::ReductionResponse>, tonic::Status>;
        /// Mca
        async fn get_valid_certs(
            &self,
            request: tonic::Request<super::GetValidCertsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetValidCertsResponse>, tonic::Status>;
        async fn get_revoked_certs(
            &self,
            request: tonic::Request<super::GetRevokedCertsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRevokedCertsResponse>, tonic::Status>;
        async fn revoke_cert(
            &self,
            request: tonic::Request<super::RevokeCertRequest>,
        ) -> std::result::Result<tonic::Response<super::RevokeCertResponse>, tonic::Status>;
        /// PC
        async fn add_pc(
            &self,
            request: tonic::Request<super::AddPcRequest>,
        ) -> std::result::Result<tonic::Response<super::AddPcResponse>, tonic::Status>;
        async fn get_all_pcs(
            &self,
            request: tonic::Request<super::GetAllPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllPcsResponse>, tonic::Status>;
        async fn get_specific_pcs(
            &self,
            request: tonic::Request<super::GetSpecificPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSpecificPcsResponse>, tonic::Status>;
        async fn delete_pcs(
            &self,
            request: tonic::Request<super::DeletePcsRequest>,
        ) -> std::result::Result<tonic::Response<super::DeletePcsResponse>, tonic::Status>;
        async fn reboot_pcs(
            &self,
            request: tonic::Request<super::RebootPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::RebootPcsResponse>, tonic::Status>;
        async fn shutdown_pcs(
            &self,
            request: tonic::Request<super::ShutdownPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::ShutdownPcsResponse>, tonic::Status>;
        /// PC Group
        async fn get_pc_groups(
            &self,
            request: tonic::Request<super::GetPcGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcGroupsResponse>, tonic::Status>;
        async fn create_pc_group(
            &self,
            request: tonic::Request<super::CreatePcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::CreatePcGroupResponse>, tonic::Status>;
        async fn put_pc_group(
            &self,
            request: tonic::Request<super::PutPcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::PutPcGroupResponse>, tonic::Status>;
        async fn patch_pc_group(
            &self,
            request: tonic::Request<super::PatchPcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchPcGroupResponse>, tonic::Status>;
        async fn delete_pc_group(
            &self,
            request: tonic::Request<super::DeletePcGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::DeletePcGroupResponse>, tonic::Status>;
        /// Role
        async fn get_roles(
            &self,
            request: tonic::Request<super::GetRolesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRolesResponse>, tonic::Status>;
        async fn get_role_users(
            &self,
            request: tonic::Request<super::GetRoleUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoleUsersResponse>, tonic::Status>;
        async fn create_role(
            &self,
            request: tonic::Request<super::CreateRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateRoleResponse>, tonic::Status>;
        async fn delete_role(
            &self,
            request: tonic::Request<super::DeleteRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteRoleResponse>, tonic::Status>;
        async fn put_role_members(
            &self,
            request: tonic::Request<super::PutRoleMembersRequest>,
        ) -> std::result::Result<tonic::Response<super::PutRoleMembersResponse>, tonic::Status>;
        async fn patch_role(
            &self,
            request: tonic::Request<super::PatchRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchRoleResponse>, tonic::Status>;
        /// Module
        async fn get_modules(
            &self,
            request: tonic::Request<super::GetModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetModulesResponse>, tonic::Status>;
        async fn upload_modules(
            &self,
            request: tonic::Request<super::UploadModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadModulesResponse>, tonic::Status>;
        async fn update_modules(
            &self,
            request: tonic::Request<super::UpdateModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateModulesResponse>, tonic::Status>;
        async fn patch_module_settings(
            &self,
            request: tonic::Request<super::PatchModuleSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchModuleSettingsResponse>, tonic::Status>;
        async fn delete_modules(
            &self,
            request: tonic::Request<super::DeleteModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteModulesResponse>, tonic::Status>;
        async fn enable_modules(
            &self,
            request: tonic::Request<super::EnableModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::EnableModulesResponse>, tonic::Status>;
        async fn disable_modules(
            &self,
            request: tonic::Request<super::DisableModulesRequest>,
        ) -> std::result::Result<tonic::Response<super::DisableModulesResponse>, tonic::Status>;
        /// IP Access Control
        async fn get_ip_access(
            &self,
            request: tonic::Request<super::GetIpAccessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetIpAccessResponse>, tonic::Status>;
        async fn post_ip(
            &self,
            request: tonic::Request<super::PostIpRequest>,
        ) -> std::result::Result<tonic::Response<super::PostIpResponse>, tonic::Status>;
        async fn delete_ip(
            &self,
            request: tonic::Request<super::DeleteIpRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIpResponse>, tonic::Status>;
        async fn put_ip_mode(
            &self,
            request: tonic::Request<super::PutIpModeRequest>,
        ) -> std::result::Result<tonic::Response<super::PutIpModeResponse>, tonic::Status>;
        /// Setting Values
        async fn get_setting_values(
            &self,
            request: tonic::Request<super::GetSettingValuesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSettingValuesResponse>, tonic::Status>;
        async fn put_setting_values(
            &self,
            request: tonic::Request<super::PutSettingValuesRequest>,
        ) -> std::result::Result<tonic::Response<super::PutSettingValuesResponse>, tonic::Status>;
        /// Users
        async fn get_users(
            &self,
            request: tonic::Request<super::GetUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::GetUsersResponse>, tonic::Status>;
        async fn create_user(
            &self,
            request: tonic::Request<super::CreateUserRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateUserResponse>, tonic::Status>;
        async fn put_users(
            &self,
            request: tonic::Request<super::PutUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::PutUsersResponse>, tonic::Status>;
        async fn patch_users(
            &self,
            request: tonic::Request<super::PatchUsersRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchUsersResponse>, tonic::Status>;
        async fn delete_user(
            &self,
            request: tonic::Request<super::DeleteUserRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteUserResponse>, tonic::Status>;
        /// Groups
        async fn get_groups(
            &self,
            request: tonic::Request<super::GetGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetGroupsResponse>, tonic::Status>;
        async fn create_group(
            &self,
            request: tonic::Request<super::CreateGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateGroupResponse>, tonic::Status>;
        async fn put_groups(
            &self,
            request: tonic::Request<super::PutGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::PutGroupsResponse>, tonic::Status>;
        async fn patch_groups(
            &self,
            request: tonic::Request<super::PatchGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchGroupsResponse>, tonic::Status>;
        async fn delete_group(
            &self,
            request: tonic::Request<super::DeleteGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteGroupResponse>, tonic::Status>;
        /// Cron
        async fn get_cron_jobs(
            &self,
            request: tonic::Request<super::GetCronJobsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCronJobsResponse>, tonic::Status>;
        async fn create_cron(
            &self,
            request: tonic::Request<super::CreateCronRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateCronResponse>, tonic::Status>;
        async fn delete_cron(
            &self,
            request: tonic::Request<super::DeleteCronRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteCronResponse>, tonic::Status>;
        async fn put_cron(
            &self,
            request: tonic::Request<super::PutCronRequest>,
        ) -> std::result::Result<tonic::Response<super::PutCronResponse>, tonic::Status>;
        async fn import_cron(
            &self,
            request: tonic::Request<super::ImportCronRequest>,
        ) -> std::result::Result<tonic::Response<super::ImportCronResponse>, tonic::Status>;
        async fn export_cron(
            &self,
            request: tonic::Request<super::ExportCronRequest>,
        ) -> std::result::Result<tonic::Response<super::ExportCronResponse>, tonic::Status>;
        /// pdir
        async fn get_pdir_pcs(
            &self,
            request: tonic::Request<super::GetPdirPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPdirPcsResponse>, tonic::Status>;
        async fn get_pdir_one(
            &self,
            request: tonic::Request<super::GetPdirOneRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPdirOneResponse>, tonic::Status>;
        async fn upload_pdir_files(
            &self,
            request: tonic::Request<super::UploadPdirFilesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadPdirFilesResponse>, tonic::Status>;
        async fn download_pdir_file(
            &self,
            request: tonic::Request<super::DownloadPdirFileRequest>,
        ) -> std::result::Result<tonic::Response<super::DownloadPdirFileResponse>, tonic::Status>;
        /// vdir
        async fn get_vdir_path(
            &self,
            request: tonic::Request<super::GetVdirPathRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVdirPathResponse>, tonic::Status>;
        async fn upload_vdir_files(
            &self,
            request: tonic::Request<super::UploadVdirFilesRequest>,
        ) -> std::result::Result<tonic::Response<super::UploadVdirFilesResponse>, tonic::Status>;
        async fn download_vdir_file(
            &self,
            request: tonic::Request<super::DownloadVdirFileRequest>,
        ) -> std::result::Result<tonic::Response<super::DownloadVdirFileResponse>, tonic::Status>;
        /// System logs
        async fn get_sys_logs(
            &self,
            request: tonic::Request<super::GetSysLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSysLogsResponse>, tonic::Status>;
        async fn query_sys_logs(
            &self,
            request: tonic::Request<super::QuerySysLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::QuerySysLogsResponse>, tonic::Status>;
        /// PC logs
        async fn get_pc_log_pcs(
            &self,
            request: tonic::Request<super::GetPcLogPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcLogPcsResponse>, tonic::Status>;
        async fn get_pc_logs(
            &self,
            request: tonic::Request<super::GetPcLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetPcLogsResponse>, tonic::Status>;
        async fn query_pc_logs(
            &self,
            request: tonic::Request<super::QueryPcLogsRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryPcLogsResponse>, tonic::Status>;
        /// Firewall
        async fn get_firewall_pcs(
            &self,
            request: tonic::Request<super::GetFirewallPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFirewallPcsResponse>, tonic::Status>;
        async fn get_firewall(
            &self,
            request: tonic::Request<super::GetFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFirewallResponse>, tonic::Status>;
        async fn add_firewall_rule(
            &self,
            request: tonic::Request<super::AddFirewallRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::AddFirewallRuleResponse>, tonic::Status>;
        async fn delete_firewall_rule(
            &self,
            request: tonic::Request<super::DeleteFirewallRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteFirewallRuleResponse>, tonic::Status>;
        async fn put_firewall_status(
            &self,
            request: tonic::Request<super::PutFirewallStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::PutFirewallStatusResponse>, tonic::Status>;
        async fn put_firewall_policy(
            &self,
            request: tonic::Request<super::PutFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::PutFirewallPolicyResponse>, tonic::Status>;
        /// Network Interface
        async fn get_all_net(
            &self,
            request: tonic::Request<super::GetAllNetRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllNetResponse>, tonic::Status>;
        async fn create_net(
            &self,
            request: tonic::Request<super::CreateNetRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateNetResponse>, tonic::Status>;
        async fn delete_net(
            &self,
            request: tonic::Request<super::DeleteNetRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteNetResponse>, tonic::Status>;
        async fn patch_net(
            &self,
            request: tonic::Request<super::PatchNetRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchNetResponse>, tonic::Status>;
        async fn put_net(
            &self,
            request: tonic::Request<super::PutNetRequest>,
        ) -> std::result::Result<tonic::Response<super::PutNetResponse>, tonic::Status>;
        async fn net_up(
            &self,
            request: tonic::Request<super::NetUpRequest>,
        ) -> std::result::Result<tonic::Response<super::NetUpResponse>, tonic::Status>;
        async fn net_down(
            &self,
            request: tonic::Request<super::NetDownRequest>,
        ) -> std::result::Result<tonic::Response<super::NetDownResponse>, tonic::Status>;
        /// Routing
        async fn get_all_route(
            &self,
            request: tonic::Request<super::GetAllRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllRouteResponse>, tonic::Status>;
        async fn create_route(
            &self,
            request: tonic::Request<super::CreateRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateRouteResponse>, tonic::Status>;
        async fn delete_route(
            &self,
            request: tonic::Request<super::DeleteRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteRouteResponse>, tonic::Status>;
        async fn patch_route(
            &self,
            request: tonic::Request<super::PatchRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchRouteResponse>, tonic::Status>;
        async fn put_route(
            &self,
            request: tonic::Request<super::PutRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::PutRouteResponse>, tonic::Status>;
        /// DNS / Hostname
        async fn get_all_dns(
            &self,
            request: tonic::Request<super::GetAllDnsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllDnsResponse>, tonic::Status>;
        async fn patch_hostname(
            &self,
            request: tonic::Request<super::PatchHostnameRequest>,
        ) -> std::result::Result<tonic::Response<super::PatchHostnameResponse>, tonic::Status>;
        async fn put_dns(
            &self,
            request: tonic::Request<super::PutDnsRequest>,
        ) -> std::result::Result<tonic::Response<super::PutDnsResponse>, tonic::Status>;
        /// Process
        async fn get_all_process(
            &self,
            request: tonic::Request<super::GetAllProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAllProcessResponse>, tonic::Status>;
        async fn get_one_process(
            &self,
            request: tonic::Request<super::GetOneProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::GetOneProcessResponse>, tonic::Status>;
        /// Process
        async fn start_process(
            &self,
            request: tonic::Request<super::StartProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StartProcessResponse>, tonic::Status>;
        async fn stop_process(
            &self,
            request: tonic::Request<super::StopProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StopProcessResponse>, tonic::Status>;
        async fn restart_process(
            &self,
            request: tonic::Request<super::RestartProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartProcessResponse>, tonic::Status>;
        async fn enable_process(
            &self,
            request: tonic::Request<super::EnableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::EnableProcessResponse>, tonic::Status>;
        async fn disable_process(
            &self,
            request: tonic::Request<super::DisableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::DisableProcessResponse>, tonic::Status>;
        async fn start_enable_process(
            &self,
            request: tonic::Request<super::StartEnableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StartEnableProcessResponse>, tonic::Status>;
        async fn stop_disable_process(
            &self,
            request: tonic::Request<super::StopDisableProcessRequest>,
        ) -> std::result::Result<tonic::Response<super::StopDisableProcessResponse>, tonic::Status>;
        /// Software Inventory
        async fn get_software(
            &self,
            request: tonic::Request<super::GetSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSoftwareResponse>, tonic::Status>;
        async fn install_software(
            &self,
            request: tonic::Request<super::InstallSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::PackageActionResponse>, tonic::Status>;
        async fn delete_software(
            &self,
            request: tonic::Request<super::DeleteSoftwareRequest>,
        ) -> std::result::Result<tonic::Response<super::PackageActionResponse>, tonic::Status>;
        /// Apache Webserver
        async fn get_apache_status(
            &self,
            request: tonic::Request<super::GetApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::GetApacheResponse>, tonic::Status>;
        async fn start_apache(
            &self,
            request: tonic::Request<super::StartApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::StartApacheResponse>, tonic::Status>;
        async fn stop_apache(
            &self,
            request: tonic::Request<super::StopApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::StopApacheResponse>, tonic::Status>;
        async fn restart_apache(
            &self,
            request: tonic::Request<super::RestartApacheRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartApacheResponse>, tonic::Status>;
        /// BIND DNS Server
        async fn get_bind_status(
            &self,
            request: tonic::Request<super::GetBindRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBindResponse>, tonic::Status>;
        async fn start_bind(
            &self,
            request: tonic::Request<super::StartBindRequest>,
        ) -> std::result::Result<tonic::Response<super::StartBindResponse>, tonic::Status>;
        async fn stop_bind(
            &self,
            request: tonic::Request<super::StopBindRequest>,
        ) -> std::result::Result<tonic::Response<super::StopBindResponse>, tonic::Status>;
        async fn restart_bind(
            &self,
            request: tonic::Request<super::RestartBindRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartBindResponse>, tonic::Status>;
        /// LDAP Server
        async fn get_ldap_status(
            &self,
            request: tonic::Request<super::GetLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::GetLdapResponse>, tonic::Status>;
        async fn start_ldap(
            &self,
            request: tonic::Request<super::StartLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::StartLdapResponse>, tonic::Status>;
        async fn stop_ldap(
            &self,
            request: tonic::Request<super::StopLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::StopLdapResponse>, tonic::Status>;
        async fn restart_ldap(
            &self,
            request: tonic::Request<super::RestartLdapRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartLdapResponse>, tonic::Status>;
        /// MySQL Server
        async fn get_my_sql_status(
            &self,
            request: tonic::Request<super::GetMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMySqlResponse>, tonic::Status>;
        async fn start_my_sql(
            &self,
            request: tonic::Request<super::StartMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::StartMySqlResponse>, tonic::Status>;
        async fn stop_my_sql(
            &self,
            request: tonic::Request<super::StopMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::StopMySqlResponse>, tonic::Status>;
        async fn restart_my_sql(
            &self,
            request: tonic::Request<super::RestartMySqlRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartMySqlResponse>, tonic::Status>;
        /// Nginx Server
        async fn get_nginx_status(
            &self,
            request: tonic::Request<super::GetNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetNginxResponse>, tonic::Status>;
        async fn start_nginx(
            &self,
            request: tonic::Request<super::StartNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::StartNginxResponse>, tonic::Status>;
        async fn stop_nginx(
            &self,
            request: tonic::Request<super::StopNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::StopNginxResponse>, tonic::Status>;
        async fn restart_nginx(
            &self,
            request: tonic::Request<super::RestartNginxRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartNginxResponse>, tonic::Status>;
        /// FTP Server
        async fn get_ftp_status(
            &self,
            request: tonic::Request<super::GetFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::GetFtpResponse>, tonic::Status>;
        async fn start_ftp(
            &self,
            request: tonic::Request<super::StartFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::StartFtpResponse>, tonic::Status>;
        async fn stop_ftp(
            &self,
            request: tonic::Request<super::StopFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::StopFtpResponse>, tonic::Status>;
        async fn restart_ftp(
            &self,
            request: tonic::Request<super::RestartFtpRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartFtpResponse>, tonic::Status>;
        /// Samba Server
        async fn get_samba_status(
            &self,
            request: tonic::Request<super::GetSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSambaResponse>, tonic::Status>;
        async fn start_samba(
            &self,
            request: tonic::Request<super::StartSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSambaResponse>, tonic::Status>;
        async fn stop_samba(
            &self,
            request: tonic::Request<super::StopSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSambaResponse>, tonic::Status>;
        async fn restart_samba(
            &self,
            request: tonic::Request<super::RestartSambaRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSambaResponse>, tonic::Status>;
        /// Server Installed/Not Installed Lists & Install
        async fn get_server_installed_pcs(
            &self,
            request: tonic::Request<super::GetServerInstalledPcsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetServerInstalledPcsResponse>, tonic::Status>;
        async fn get_server_not_installed_pcs(
            &self,
            request: tonic::Request<super::GetServerNotInstalledPcsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetServerNotInstalledPcsResponse>,
            tonic::Status,
        >;
        async fn install_server(
            &self,
            request: tonic::Request<super::InstallServerRequest>,
        ) -> std::result::Result<tonic::Response<super::InstallServerResponse>, tonic::Status>;
        /// Squid
        async fn get_squid(
            &self,
            request: tonic::Request<super::GetSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSquidResponse>, tonic::Status>;
        async fn start_squid(
            &self,
            request: tonic::Request<super::StartSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSquidResponse>, tonic::Status>;
        async fn stop_squid(
            &self,
            request: tonic::Request<super::StopSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSquidResponse>, tonic::Status>;
        async fn restart_squid(
            &self,
            request: tonic::Request<super::RestartSquidRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSquidResponse>, tonic::Status>;
        /// SSH
        async fn get_ssh(
            &self,
            request: tonic::Request<super::GetSshRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSshResponse>, tonic::Status>;
        async fn start_ssh(
            &self,
            request: tonic::Request<super::StartSshRequest>,
        ) -> std::result::Result<tonic::Response<super::StartSshResponse>, tonic::Status>;
        async fn stop_ssh(
            &self,
            request: tonic::Request<super::StopSshRequest>,
        ) -> std::result::Result<tonic::Response<super::StopSshResponse>, tonic::Status>;
        async fn restart_ssh(
            &self,
            request: tonic::Request<super::RestartSshRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartSshResponse>, tonic::Status>;
    }
    /// ========== Service ==========
    #[derive(Debug)]
    pub struct RestfulServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RestfulServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports
        /// it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RestfulServiceServer<T>
    where
        T: RestfulService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/restful.RestfulService/Login" => {
                    #[allow(non_camel_case_types)]
                    struct LoginSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::LoginRequest> for LoginSvc<T> {
                        type Response = super::LoginResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LoginRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as RestfulService>::login(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LoginSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllInfoSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllInfoRequest> for GetAllInfoSvc<T> {
                        type Response = super::GetAllInfoResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetInfoSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetInfoRequest> for GetInfoSvc<T> {
                        type Response = super::GetInfoResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetConfigRequest> for GetConfigSvc<T> {
                        type Response = super::GetConfigResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/BackupNow" => {
                    #[allow(non_camel_case_types)]
                    struct BackupNowSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::BackupNowRequest> for BackupNowSvc<T> {
                        type Response = super::BackupNowResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BackupNowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::backup_now(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BackupNowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetBackups" => {
                    #[allow(non_camel_case_types)]
                    struct GetBackupsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetBackupsRequest> for GetBackupsSvc<T> {
                        type Response = super::GetBackupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBackupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_backups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBackupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/ReduceBackup" => {
                    #[allow(non_camel_case_types)]
                    struct ReduceBackupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::ReductionRequest>
                        for ReduceBackupSvc<T>
                    {
                        type Response = super::ReductionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReductionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::reduce_backup(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReduceBackupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetValidCerts" => {
                    #[allow(non_camel_case_types)]
                    struct GetValidCertsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetValidCertsRequest>
                        for GetValidCertsSvc<T>
                    {
                        type Response = super::GetValidCertsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetValidCertsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_valid_certs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetValidCertsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetRevokedCerts" => {
                    #[allow(non_camel_case_types)]
                    struct GetRevokedCertsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetRevokedCertsRequest>
                        for GetRevokedCertsSvc<T>
                    {
                        type Response = super::GetRevokedCertsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRevokedCertsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_revoked_certs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRevokedCertsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RevokeCert" => {
                    #[allow(non_camel_case_types)]
                    struct RevokeCertSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RevokeCertRequest> for RevokeCertSvc<T> {
                        type Response = super::RevokeCertResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RevokeCertRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::revoke_cert(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RevokeCertSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/AddPc" => {
                    #[allow(non_camel_case_types)]
                    struct AddPcSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::AddPcRequest> for AddPcSvc<T> {
                        type Response = super::AddPcResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddPcRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as RestfulService>::add_pc(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddPcSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllPcsRequest> for GetAllPcsSvc<T> {
                        type Response = super::GetAllPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSpecificPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetSpecificPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetSpecificPcsRequest>
                        for GetSpecificPcsSvc<T>
                    {
                        type Response = super::GetSpecificPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSpecificPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_specific_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSpecificPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeletePcs" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeletePcsRequest> for DeletePcsSvc<T> {
                        type Response = super::DeletePcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeletePcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RebootPcs" => {
                    #[allow(non_camel_case_types)]
                    struct RebootPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RebootPcsRequest> for RebootPcsSvc<T> {
                        type Response = super::RebootPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RebootPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::reboot_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RebootPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/ShutdownPcs" => {
                    #[allow(non_camel_case_types)]
                    struct ShutdownPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::ShutdownPcsRequest>
                        for ShutdownPcsSvc<T>
                    {
                        type Response = super::ShutdownPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ShutdownPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::shutdown_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShutdownPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetPcGroups" => {
                    #[allow(non_camel_case_types)]
                    struct GetPcGroupsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetPcGroupsRequest>
                        for GetPcGroupsSvc<T>
                    {
                        type Response = super::GetPcGroupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPcGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_pc_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPcGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreatePcGroup" => {
                    #[allow(non_camel_case_types)]
                    struct CreatePcGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreatePcGroupRequest>
                        for CreatePcGroupSvc<T>
                    {
                        type Response = super::CreatePcGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreatePcGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_pc_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreatePcGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutPcGroup" => {
                    #[allow(non_camel_case_types)]
                    struct PutPcGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutPcGroupRequest> for PutPcGroupSvc<T> {
                        type Response = super::PutPcGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutPcGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_pc_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutPcGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchPcGroup" => {
                    #[allow(non_camel_case_types)]
                    struct PatchPcGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchPcGroupRequest>
                        for PatchPcGroupSvc<T>
                    {
                        type Response = super::PatchPcGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchPcGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_pc_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchPcGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeletePcGroup" => {
                    #[allow(non_camel_case_types)]
                    struct DeletePcGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeletePcGroupRequest>
                        for DeletePcGroupSvc<T>
                    {
                        type Response = super::DeletePcGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeletePcGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_pc_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeletePcGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetRoles" => {
                    #[allow(non_camel_case_types)]
                    struct GetRolesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetRolesRequest> for GetRolesSvc<T> {
                        type Response = super::GetRolesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRolesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_roles(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRolesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetRoleUsers" => {
                    #[allow(non_camel_case_types)]
                    struct GetRoleUsersSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetRoleUsersRequest>
                        for GetRoleUsersSvc<T>
                    {
                        type Response = super::GetRoleUsersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetRoleUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_role_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetRoleUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateRole" => {
                    #[allow(non_camel_case_types)]
                    struct CreateRoleSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateRoleRequest> for CreateRoleSvc<T> {
                        type Response = super::CreateRoleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRoleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_role(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateRoleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteRole" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteRoleSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteRoleRequest> for DeleteRoleSvc<T> {
                        type Response = super::DeleteRoleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRoleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_role(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteRoleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutRoleMembers" => {
                    #[allow(non_camel_case_types)]
                    struct PutRoleMembersSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::PutRoleMembersRequest>
                        for PutRoleMembersSvc<T>
                    {
                        type Response = super::PutRoleMembersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutRoleMembersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_role_members(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutRoleMembersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchRole" => {
                    #[allow(non_camel_case_types)]
                    struct PatchRoleSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchRoleRequest> for PatchRoleSvc<T> {
                        type Response = super::PatchRoleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchRoleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_role(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchRoleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetModules" => {
                    #[allow(non_camel_case_types)]
                    struct GetModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetModulesRequest> for GetModulesSvc<T> {
                        type Response = super::GetModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/UploadModules" => {
                    #[allow(non_camel_case_types)]
                    struct UploadModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::UploadModulesRequest>
                        for UploadModulesSvc<T>
                    {
                        type Response = super::UploadModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::upload_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/UpdateModules" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::UpdateModulesRequest>
                        for UpdateModulesSvc<T>
                    {
                        type Response = super::UpdateModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::update_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchModuleSettings" => {
                    #[allow(non_camel_case_types)]
                    struct PatchModuleSettingsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::PatchModuleSettingsRequest>
                        for PatchModuleSettingsSvc<T>
                    {
                        type Response = super::PatchModuleSettingsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchModuleSettingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_module_settings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchModuleSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteModules" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteModulesRequest>
                        for DeleteModulesSvc<T>
                    {
                        type Response = super::DeleteModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/EnableModules" => {
                    #[allow(non_camel_case_types)]
                    struct EnableModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::EnableModulesRequest>
                        for EnableModulesSvc<T>
                    {
                        type Response = super::EnableModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EnableModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::enable_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EnableModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DisableModules" => {
                    #[allow(non_camel_case_types)]
                    struct DisableModulesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DisableModulesRequest>
                        for DisableModulesSvc<T>
                    {
                        type Response = super::DisableModulesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DisableModulesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::disable_modules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DisableModulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetIpAccess" => {
                    #[allow(non_camel_case_types)]
                    struct GetIpAccessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetIpAccessRequest>
                        for GetIpAccessSvc<T>
                    {
                        type Response = super::GetIpAccessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetIpAccessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_ip_access(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetIpAccessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PostIp" => {
                    #[allow(non_camel_case_types)]
                    struct PostIpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PostIpRequest> for PostIpSvc<T> {
                        type Response = super::PostIpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PostIpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::post_ip(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PostIpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteIp" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteIpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteIpRequest> for DeleteIpSvc<T> {
                        type Response = super::DeleteIpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteIpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_ip(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteIpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutIpMode" => {
                    #[allow(non_camel_case_types)]
                    struct PutIpModeSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutIpModeRequest> for PutIpModeSvc<T> {
                        type Response = super::PutIpModeResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutIpModeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_ip_mode(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutIpModeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSettingValues" => {
                    #[allow(non_camel_case_types)]
                    struct GetSettingValuesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetSettingValuesRequest>
                        for GetSettingValuesSvc<T>
                    {
                        type Response = super::GetSettingValuesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSettingValuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_setting_values(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSettingValuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutSettingValues" => {
                    #[allow(non_camel_case_types)]
                    struct PutSettingValuesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::PutSettingValuesRequest>
                        for PutSettingValuesSvc<T>
                    {
                        type Response = super::PutSettingValuesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutSettingValuesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_setting_values(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutSettingValuesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetUsers" => {
                    #[allow(non_camel_case_types)]
                    struct GetUsersSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetUsersRequest> for GetUsersSvc<T> {
                        type Response = super::GetUsersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateUser" => {
                    #[allow(non_camel_case_types)]
                    struct CreateUserSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateUserRequest> for CreateUserSvc<T> {
                        type Response = super::CreateUserResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateUserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutUsers" => {
                    #[allow(non_camel_case_types)]
                    struct PutUsersSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutUsersRequest> for PutUsersSvc<T> {
                        type Response = super::PutUsersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchUsers" => {
                    #[allow(non_camel_case_types)]
                    struct PatchUsersSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchUsersRequest> for PatchUsersSvc<T> {
                        type Response = super::PatchUsersResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchUsersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_users(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchUsersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteUser" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteUserSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteUserRequest> for DeleteUserSvc<T> {
                        type Response = super::DeleteUserResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteUserRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_user(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteUserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetGroups" => {
                    #[allow(non_camel_case_types)]
                    struct GetGroupsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetGroupsRequest> for GetGroupsSvc<T> {
                        type Response = super::GetGroupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateGroup" => {
                    #[allow(non_camel_case_types)]
                    struct CreateGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateGroupRequest>
                        for CreateGroupSvc<T>
                    {
                        type Response = super::CreateGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutGroups" => {
                    #[allow(non_camel_case_types)]
                    struct PutGroupsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutGroupsRequest> for PutGroupsSvc<T> {
                        type Response = super::PutGroupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchGroups" => {
                    #[allow(non_camel_case_types)]
                    struct PatchGroupsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchGroupsRequest>
                        for PatchGroupsSvc<T>
                    {
                        type Response = super::PatchGroupsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteGroup" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteGroupSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteGroupRequest>
                        for DeleteGroupSvc<T>
                    {
                        type Response = super::DeleteGroupResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_group(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetCronJobs" => {
                    #[allow(non_camel_case_types)]
                    struct GetCronJobsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetCronJobsRequest>
                        for GetCronJobsSvc<T>
                    {
                        type Response = super::GetCronJobsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCronJobsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_cron_jobs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCronJobsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateCron" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCronSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateCronRequest> for CreateCronSvc<T> {
                        type Response = super::CreateCronResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCronRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_cron(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCronSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteCron" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteCronSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteCronRequest> for DeleteCronSvc<T> {
                        type Response = super::DeleteCronResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteCronRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_cron(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteCronSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutCron" => {
                    #[allow(non_camel_case_types)]
                    struct PutCronSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutCronRequest> for PutCronSvc<T> {
                        type Response = super::PutCronResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutCronRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_cron(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutCronSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/ImportCron" => {
                    #[allow(non_camel_case_types)]
                    struct ImportCronSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::ImportCronRequest> for ImportCronSvc<T> {
                        type Response = super::ImportCronResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ImportCronRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::import_cron(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ImportCronSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/ExportCron" => {
                    #[allow(non_camel_case_types)]
                    struct ExportCronSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::ExportCronRequest> for ExportCronSvc<T> {
                        type Response = super::ExportCronResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportCronRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::export_cron(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExportCronSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetPdirPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetPdirPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetPdirPcsRequest> for GetPdirPcsSvc<T> {
                        type Response = super::GetPdirPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPdirPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_pdir_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPdirPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetPdirOne" => {
                    #[allow(non_camel_case_types)]
                    struct GetPdirOneSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetPdirOneRequest> for GetPdirOneSvc<T> {
                        type Response = super::GetPdirOneResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPdirOneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_pdir_one(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPdirOneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/UploadPdirFiles" => {
                    #[allow(non_camel_case_types)]
                    struct UploadPdirFilesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::UploadPdirFilesRequest>
                        for UploadPdirFilesSvc<T>
                    {
                        type Response = super::UploadPdirFilesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadPdirFilesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::upload_pdir_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadPdirFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DownloadPdirFile" => {
                    #[allow(non_camel_case_types)]
                    struct DownloadPdirFileSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DownloadPdirFileRequest>
                        for DownloadPdirFileSvc<T>
                    {
                        type Response = super::DownloadPdirFileResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DownloadPdirFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::download_pdir_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DownloadPdirFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetVdirPath" => {
                    #[allow(non_camel_case_types)]
                    struct GetVdirPathSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetVdirPathRequest>
                        for GetVdirPathSvc<T>
                    {
                        type Response = super::GetVdirPathResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetVdirPathRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_vdir_path(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetVdirPathSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/UploadVdirFiles" => {
                    #[allow(non_camel_case_types)]
                    struct UploadVdirFilesSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::UploadVdirFilesRequest>
                        for UploadVdirFilesSvc<T>
                    {
                        type Response = super::UploadVdirFilesResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UploadVdirFilesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::upload_vdir_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UploadVdirFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DownloadVdirFile" => {
                    #[allow(non_camel_case_types)]
                    struct DownloadVdirFileSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DownloadVdirFileRequest>
                        for DownloadVdirFileSvc<T>
                    {
                        type Response = super::DownloadVdirFileResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DownloadVdirFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::download_vdir_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DownloadVdirFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSysLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetSysLogsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetSysLogsRequest> for GetSysLogsSvc<T> {
                        type Response = super::GetSysLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSysLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_sys_logs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSysLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/QuerySysLogs" => {
                    #[allow(non_camel_case_types)]
                    struct QuerySysLogsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::QuerySysLogsRequest>
                        for QuerySysLogsSvc<T>
                    {
                        type Response = super::QuerySysLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QuerySysLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::query_sys_logs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QuerySysLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetPcLogPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetPcLogPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetPcLogPcsRequest>
                        for GetPcLogPcsSvc<T>
                    {
                        type Response = super::GetPcLogPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPcLogPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_pc_log_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPcLogPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetPcLogs" => {
                    #[allow(non_camel_case_types)]
                    struct GetPcLogsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetPcLogsRequest> for GetPcLogsSvc<T> {
                        type Response = super::GetPcLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPcLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_pc_logs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPcLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/QueryPcLogs" => {
                    #[allow(non_camel_case_types)]
                    struct QueryPcLogsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::QueryPcLogsRequest>
                        for QueryPcLogsSvc<T>
                    {
                        type Response = super::QueryPcLogsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryPcLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::query_pc_logs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryPcLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetFirewallPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetFirewallPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetFirewallPcsRequest>
                        for GetFirewallPcsSvc<T>
                    {
                        type Response = super::GetFirewallPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFirewallPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_firewall_pcs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFirewallPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetFirewall" => {
                    #[allow(non_camel_case_types)]
                    struct GetFirewallSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetFirewallRequest>
                        for GetFirewallSvc<T>
                    {
                        type Response = super::GetFirewallResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFirewallRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_firewall(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFirewallSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/AddFirewallRule" => {
                    #[allow(non_camel_case_types)]
                    struct AddFirewallRuleSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::AddFirewallRuleRequest>
                        for AddFirewallRuleSvc<T>
                    {
                        type Response = super::AddFirewallRuleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddFirewallRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::add_firewall_rule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddFirewallRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteFirewallRule" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteFirewallRuleSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DeleteFirewallRuleRequest>
                        for DeleteFirewallRuleSvc<T>
                    {
                        type Response = super::DeleteFirewallRuleResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteFirewallRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_firewall_rule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteFirewallRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutFirewallStatus" => {
                    #[allow(non_camel_case_types)]
                    struct PutFirewallStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::PutFirewallStatusRequest>
                        for PutFirewallStatusSvc<T>
                    {
                        type Response = super::PutFirewallStatusResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutFirewallStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_firewall_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutFirewallStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutFirewallPolicy" => {
                    #[allow(non_camel_case_types)]
                    struct PutFirewallPolicySvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::PutFirewallPolicyRequest>
                        for PutFirewallPolicySvc<T>
                    {
                        type Response = super::PutFirewallPolicyResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutFirewallPolicyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_firewall_policy(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutFirewallPolicySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllNet" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllNetSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllNetRequest> for GetAllNetSvc<T> {
                        type Response = super::GetAllNetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllNetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_net(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllNetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateNet" => {
                    #[allow(non_camel_case_types)]
                    struct CreateNetSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateNetRequest> for CreateNetSvc<T> {
                        type Response = super::CreateNetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateNetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_net(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateNetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteNet" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteNetSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteNetRequest> for DeleteNetSvc<T> {
                        type Response = super::DeleteNetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteNetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_net(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteNetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchNet" => {
                    #[allow(non_camel_case_types)]
                    struct PatchNetSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchNetRequest> for PatchNetSvc<T> {
                        type Response = super::PatchNetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchNetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_net(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchNetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutNet" => {
                    #[allow(non_camel_case_types)]
                    struct PutNetSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutNetRequest> for PutNetSvc<T> {
                        type Response = super::PutNetResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutNetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_net(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutNetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/NetUp" => {
                    #[allow(non_camel_case_types)]
                    struct NetUpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::NetUpRequest> for NetUpSvc<T> {
                        type Response = super::NetUpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetUpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut =
                                async move { <T as RestfulService>::net_up(&inner, request).await };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NetUpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/NetDown" => {
                    #[allow(non_camel_case_types)]
                    struct NetDownSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::NetDownRequest> for NetDownSvc<T> {
                        type Response = super::NetDownResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetDownRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::net_down(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NetDownSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllRoute" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllRouteSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllRouteRequest>
                        for GetAllRouteSvc<T>
                    {
                        type Response = super::GetAllRouteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllRouteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_route(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllRouteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/CreateRoute" => {
                    #[allow(non_camel_case_types)]
                    struct CreateRouteSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::CreateRouteRequest>
                        for CreateRouteSvc<T>
                    {
                        type Response = super::CreateRouteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateRouteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::create_route(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateRouteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteRoute" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteRouteSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::DeleteRouteRequest>
                        for DeleteRouteSvc<T>
                    {
                        type Response = super::DeleteRouteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRouteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_route(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteRouteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchRoute" => {
                    #[allow(non_camel_case_types)]
                    struct PatchRouteSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchRouteRequest> for PatchRouteSvc<T> {
                        type Response = super::PatchRouteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchRouteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_route(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchRouteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutRoute" => {
                    #[allow(non_camel_case_types)]
                    struct PutRouteSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutRouteRequest> for PutRouteSvc<T> {
                        type Response = super::PutRouteResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutRouteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_route(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutRouteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllDns" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllDnsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllDnsRequest> for GetAllDnsSvc<T> {
                        type Response = super::GetAllDnsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllDnsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_dns(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllDnsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PatchHostname" => {
                    #[allow(non_camel_case_types)]
                    struct PatchHostnameSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PatchHostnameRequest>
                        for PatchHostnameSvc<T>
                    {
                        type Response = super::PatchHostnameResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PatchHostnameRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::patch_hostname(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PatchHostnameSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/PutDns" => {
                    #[allow(non_camel_case_types)]
                    struct PutDnsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::PutDnsRequest> for PutDnsSvc<T> {
                        type Response = super::PutDnsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PutDnsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::put_dns(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PutDnsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetAllProcess" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetAllProcessRequest>
                        for GetAllProcessSvc<T>
                    {
                        type Response = super::GetAllProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_all_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetOneProcess" => {
                    #[allow(non_camel_case_types)]
                    struct GetOneProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetOneProcessRequest>
                        for GetOneProcessSvc<T>
                    {
                        type Response = super::GetOneProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOneProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_one_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOneProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartProcess" => {
                    #[allow(non_camel_case_types)]
                    struct StartProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartProcessRequest>
                        for StartProcessSvc<T>
                    {
                        type Response = super::StartProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopProcess" => {
                    #[allow(non_camel_case_types)]
                    struct StopProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopProcessRequest>
                        for StopProcessSvc<T>
                    {
                        type Response = super::StopProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartProcess" => {
                    #[allow(non_camel_case_types)]
                    struct RestartProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::RestartProcessRequest>
                        for RestartProcessSvc<T>
                    {
                        type Response = super::RestartProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/EnableProcess" => {
                    #[allow(non_camel_case_types)]
                    struct EnableProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::EnableProcessRequest>
                        for EnableProcessSvc<T>
                    {
                        type Response = super::EnableProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EnableProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::enable_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EnableProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DisableProcess" => {
                    #[allow(non_camel_case_types)]
                    struct DisableProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DisableProcessRequest>
                        for DisableProcessSvc<T>
                    {
                        type Response = super::DisableProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DisableProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::disable_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DisableProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartEnableProcess" => {
                    #[allow(non_camel_case_types)]
                    struct StartEnableProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::StartEnableProcessRequest>
                        for StartEnableProcessSvc<T>
                    {
                        type Response = super::StartEnableProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartEnableProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_enable_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartEnableProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopDisableProcess" => {
                    #[allow(non_camel_case_types)]
                    struct StopDisableProcessSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::StopDisableProcessRequest>
                        for StopDisableProcessSvc<T>
                    {
                        type Response = super::StopDisableProcessResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopDisableProcessRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_disable_process(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopDisableProcessSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSoftware" => {
                    #[allow(non_camel_case_types)]
                    struct GetSoftwareSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetSoftwareRequest>
                        for GetSoftwareSvc<T>
                    {
                        type Response = super::GetSoftwareResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSoftwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_software(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSoftwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/InstallSoftware" => {
                    #[allow(non_camel_case_types)]
                    struct InstallSoftwareSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::InstallSoftwareRequest>
                        for InstallSoftwareSvc<T>
                    {
                        type Response = super::PackageActionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InstallSoftwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::install_software(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InstallSoftwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/DeleteSoftware" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteSoftwareSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::DeleteSoftwareRequest>
                        for DeleteSoftwareSvc<T>
                    {
                        type Response = super::PackageActionResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteSoftwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::delete_software(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteSoftwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetApacheStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetApacheStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetApacheRequest>
                        for GetApacheStatusSvc<T>
                    {
                        type Response = super::GetApacheResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetApacheRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_apache_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetApacheStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartApache" => {
                    #[allow(non_camel_case_types)]
                    struct StartApacheSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartApacheRequest>
                        for StartApacheSvc<T>
                    {
                        type Response = super::StartApacheResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartApacheRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_apache(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartApacheSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopApache" => {
                    #[allow(non_camel_case_types)]
                    struct StopApacheSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopApacheRequest> for StopApacheSvc<T> {
                        type Response = super::StopApacheResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopApacheRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_apache(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopApacheSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartApache" => {
                    #[allow(non_camel_case_types)]
                    struct RestartApacheSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartApacheRequest>
                        for RestartApacheSvc<T>
                    {
                        type Response = super::RestartApacheResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartApacheRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_apache(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartApacheSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetBindStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetBindStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetBindRequest> for GetBindStatusSvc<T> {
                        type Response = super::GetBindResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBindRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_bind_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBindStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartBind" => {
                    #[allow(non_camel_case_types)]
                    struct StartBindSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartBindRequest> for StartBindSvc<T> {
                        type Response = super::StartBindResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartBindRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_bind(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartBindSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopBind" => {
                    #[allow(non_camel_case_types)]
                    struct StopBindSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopBindRequest> for StopBindSvc<T> {
                        type Response = super::StopBindResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopBindRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_bind(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopBindSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartBind" => {
                    #[allow(non_camel_case_types)]
                    struct RestartBindSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartBindRequest>
                        for RestartBindSvc<T>
                    {
                        type Response = super::RestartBindResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartBindRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_bind(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartBindSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetLdapStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetLdapStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetLdapRequest> for GetLdapStatusSvc<T> {
                        type Response = super::GetLdapResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetLdapRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_ldap_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetLdapStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartLdap" => {
                    #[allow(non_camel_case_types)]
                    struct StartLdapSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartLdapRequest> for StartLdapSvc<T> {
                        type Response = super::StartLdapResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartLdapRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_ldap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartLdapSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopLdap" => {
                    #[allow(non_camel_case_types)]
                    struct StopLdapSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopLdapRequest> for StopLdapSvc<T> {
                        type Response = super::StopLdapResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopLdapRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_ldap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopLdapSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartLdap" => {
                    #[allow(non_camel_case_types)]
                    struct RestartLdapSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartLdapRequest>
                        for RestartLdapSvc<T>
                    {
                        type Response = super::RestartLdapResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartLdapRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_ldap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartLdapSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetMySqlStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetMySqlStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetMySqlRequest>
                        for GetMySqlStatusSvc<T>
                    {
                        type Response = super::GetMySqlResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMySqlRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_my_sql_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetMySqlStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartMySql" => {
                    #[allow(non_camel_case_types)]
                    struct StartMySqlSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartMySqlRequest> for StartMySqlSvc<T> {
                        type Response = super::StartMySqlResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartMySqlRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_my_sql(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartMySqlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopMySql" => {
                    #[allow(non_camel_case_types)]
                    struct StopMySqlSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopMySqlRequest> for StopMySqlSvc<T> {
                        type Response = super::StopMySqlResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopMySqlRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_my_sql(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopMySqlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartMySql" => {
                    #[allow(non_camel_case_types)]
                    struct RestartMySqlSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartMySqlRequest>
                        for RestartMySqlSvc<T>
                    {
                        type Response = super::RestartMySqlResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartMySqlRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_my_sql(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartMySqlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetNginxStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetNginxStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetNginxRequest>
                        for GetNginxStatusSvc<T>
                    {
                        type Response = super::GetNginxResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNginxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_nginx_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNginxStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartNginx" => {
                    #[allow(non_camel_case_types)]
                    struct StartNginxSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartNginxRequest> for StartNginxSvc<T> {
                        type Response = super::StartNginxResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartNginxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_nginx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartNginxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopNginx" => {
                    #[allow(non_camel_case_types)]
                    struct StopNginxSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopNginxRequest> for StopNginxSvc<T> {
                        type Response = super::StopNginxResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopNginxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_nginx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopNginxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartNginx" => {
                    #[allow(non_camel_case_types)]
                    struct RestartNginxSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartNginxRequest>
                        for RestartNginxSvc<T>
                    {
                        type Response = super::RestartNginxResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartNginxRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_nginx(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartNginxSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetFtpStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetFtpStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetFtpRequest> for GetFtpStatusSvc<T> {
                        type Response = super::GetFtpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetFtpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_ftp_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetFtpStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartFtp" => {
                    #[allow(non_camel_case_types)]
                    struct StartFtpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartFtpRequest> for StartFtpSvc<T> {
                        type Response = super::StartFtpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartFtpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_ftp(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartFtpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopFtp" => {
                    #[allow(non_camel_case_types)]
                    struct StopFtpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopFtpRequest> for StopFtpSvc<T> {
                        type Response = super::StopFtpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopFtpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_ftp(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopFtpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartFtp" => {
                    #[allow(non_camel_case_types)]
                    struct RestartFtpSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartFtpRequest> for RestartFtpSvc<T> {
                        type Response = super::RestartFtpResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartFtpRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_ftp(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartFtpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSambaStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetSambaStatusSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetSambaRequest>
                        for GetSambaStatusSvc<T>
                    {
                        type Response = super::GetSambaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSambaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_samba_status(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSambaStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartSamba" => {
                    #[allow(non_camel_case_types)]
                    struct StartSambaSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartSambaRequest> for StartSambaSvc<T> {
                        type Response = super::StartSambaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartSambaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_samba(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartSambaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopSamba" => {
                    #[allow(non_camel_case_types)]
                    struct StopSambaSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopSambaRequest> for StopSambaSvc<T> {
                        type Response = super::StopSambaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopSambaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_samba(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopSambaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartSamba" => {
                    #[allow(non_camel_case_types)]
                    struct RestartSambaSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartSambaRequest>
                        for RestartSambaSvc<T>
                    {
                        type Response = super::RestartSambaResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartSambaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_samba(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartSambaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetServerInstalledPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerInstalledPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetServerInstalledPcsRequest>
                        for GetServerInstalledPcsSvc<T>
                    {
                        type Response = super::GetServerInstalledPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServerInstalledPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_server_installed_pcs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerInstalledPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetServerNotInstalledPcs" => {
                    #[allow(non_camel_case_types)]
                    struct GetServerNotInstalledPcsSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService>
                        tonic::server::UnaryService<super::GetServerNotInstalledPcsRequest>
                        for GetServerNotInstalledPcsSvc<T>
                    {
                        type Response = super::GetServerNotInstalledPcsResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetServerNotInstalledPcsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_server_not_installed_pcs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetServerNotInstalledPcsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/InstallServer" => {
                    #[allow(non_camel_case_types)]
                    struct InstallServerSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::InstallServerRequest>
                        for InstallServerSvc<T>
                    {
                        type Response = super::InstallServerResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InstallServerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::install_server(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InstallServerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSquid" => {
                    #[allow(non_camel_case_types)]
                    struct GetSquidSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetSquidRequest> for GetSquidSvc<T> {
                        type Response = super::GetSquidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSquidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_squid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSquidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartSquid" => {
                    #[allow(non_camel_case_types)]
                    struct StartSquidSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartSquidRequest> for StartSquidSvc<T> {
                        type Response = super::StartSquidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartSquidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_squid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartSquidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopSquid" => {
                    #[allow(non_camel_case_types)]
                    struct StopSquidSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopSquidRequest> for StopSquidSvc<T> {
                        type Response = super::StopSquidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopSquidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_squid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopSquidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartSquid" => {
                    #[allow(non_camel_case_types)]
                    struct RestartSquidSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartSquidRequest>
                        for RestartSquidSvc<T>
                    {
                        type Response = super::RestartSquidResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartSquidRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_squid(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartSquidSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/GetSsh" => {
                    #[allow(non_camel_case_types)]
                    struct GetSshSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::GetSshRequest> for GetSshSvc<T> {
                        type Response = super::GetSshResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSshRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::get_ssh(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSshSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StartSsh" => {
                    #[allow(non_camel_case_types)]
                    struct StartSshSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StartSshRequest> for StartSshSvc<T> {
                        type Response = super::StartSshResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartSshRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::start_ssh(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartSshSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/StopSsh" => {
                    #[allow(non_camel_case_types)]
                    struct StopSshSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::StopSshRequest> for StopSshSvc<T> {
                        type Response = super::StopSshResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopSshRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::stop_ssh(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopSshSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/restful.RestfulService/RestartSsh" => {
                    #[allow(non_camel_case_types)]
                    struct RestartSshSvc<T: RestfulService>(pub Arc<T>);
                    impl<T: RestfulService> tonic::server::UnaryService<super::RestartSshRequest> for RestartSshSvc<T> {
                        type Response = super::RestartSshResponse;
                        type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartSshRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RestfulService>::restart_ssh(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartSshSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => Box::pin(async move {
                    let mut response = http::Response::new(tonic::body::Body::default());
                    let headers = response.headers_mut();
                    headers.insert(
                        tonic::Status::GRPC_STATUS,
                        (tonic::Code::Unimplemented as i32).into(),
                    );
                    headers.insert(http::header::CONTENT_TYPE, tonic::metadata::GRPC_CONTENT_TYPE);
                    Ok(response)
                }),
            }
        }
    }
    impl<T> Clone for RestfulServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "restful.RestfulService";
    impl<T> tonic::server::NamedService for RestfulServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
